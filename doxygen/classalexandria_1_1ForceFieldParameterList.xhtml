<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACT: alexandria::ForceFieldParameterList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACT
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classalexandria_1_1ForceFieldParameterList.xhtml',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classalexandria_1_1ForceFieldParameterList-members.xhtml">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">alexandria::ForceFieldParameterList Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;act/forcefield/forcefield_parameterlist.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Class to hold the parameters for an interaction type. </p>
<p>This class hold a list of parameters of a certain type for a force field. It is important that the class does not hold any implicit information. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0078c9a4a6a604352c8790512c1b913c" id="r_a0078c9a4a6a604352c8790512c1b913c"><td class="memItemLeft" align="right" valign="top"><a id="a0078c9a4a6a604352c8790512c1b913c" name="a0078c9a4a6a604352c8790512c1b913c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ForceFieldParameterList</b> ()</td></tr>
<tr class="memdesc:a0078c9a4a6a604352c8790512c1b913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor for helper nodes. <br /></td></tr>
<tr class="separator:a0078c9a4a6a604352c8790512c1b913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7933e2e5943dd2f1a125cd9dd8b4d54c" id="r_a7933e2e5943dd2f1a125cd9dd8b4d54c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7933e2e5943dd2f1a125cd9dd8b4d54c">ForceFieldParameterList</a> (const std::string &amp;function, <a class="el" href="namespacealexandria.xhtml#a35774efb4237acf884386e0292d213ab">CanSwap</a> <a class="el" href="#a859f9c84e2b6bc90920e2ef25bbf2a74">canSwap</a>)</td></tr>
<tr class="memdesc:a7933e2e5943dd2f1a125cd9dd8b4d54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a7933e2e5943dd2f1a125cd9dd8b4d54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629a47784accff97233bf1c25f5494b" id="r_ac629a47784accff97233bf1c25f5494b"><td class="memItemLeft" align="right" valign="top"><a id="ac629a47784accff97233bf1c25f5494b" name="ac629a47784accff97233bf1c25f5494b"></a>
<a class="el" href="namespacealexandria.xhtml#a5fda7c42f8b51a01e84155acb117dc6d">Potential</a>&#160;</td><td class="memItemRight" valign="bottom"><b>potential</b> () const</td></tr>
<tr class="memdesc:ac629a47784accff97233bf1c25f5494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the function name. <br /></td></tr>
<tr class="separator:ac629a47784accff97233bf1c25f5494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20fba8c3b19bca7a6ed8060505e3710" id="r_ab20fba8c3b19bca7a6ed8060505e3710"><td class="memItemLeft" align="right" valign="top"><a id="ab20fba8c3b19bca7a6ed8060505e3710" name="ab20fba8c3b19bca7a6ed8060505e3710"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFunction</b> (const std::string &amp;function)</td></tr>
<tr class="memdesc:ab20fba8c3b19bca7a6ed8060505e3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function name. <br /></td></tr>
<tr class="separator:ab20fba8c3b19bca7a6ed8060505e3710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859f9c84e2b6bc90920e2ef25bbf2a74" id="r_a859f9c84e2b6bc90920e2ef25bbf2a74"><td class="memItemLeft" align="right" valign="top"><a id="a859f9c84e2b6bc90920e2ef25bbf2a74" name="a859f9c84e2b6bc90920e2ef25bbf2a74"></a>
<a class="el" href="namespacealexandria.xhtml#a35774efb4237acf884386e0292d213ab">CanSwap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>canSwap</b> () const</td></tr>
<tr class="memdesc:a859f9c84e2b6bc90920e2ef25bbf2a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether or not identifiers can be swapped. <br /></td></tr>
<tr class="separator:a859f9c84e2b6bc90920e2ef25bbf2a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03902ad8e261e0f9751b35ae04bdd45" id="r_ac03902ad8e261e0f9751b35ae04bdd45"><td class="memItemLeft" align="right" valign="top"><a id="ac03902ad8e261e0f9751b35ae04bdd45" name="ac03902ad8e261e0f9751b35ae04bdd45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCanSwap</b> (<a class="el" href="namespacealexandria.xhtml#a35774efb4237acf884386e0292d213ab">CanSwap</a> cs)</td></tr>
<tr class="memdesc:ac03902ad8e261e0f9751b35ae04bdd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not identifiers can be swapped. <br /></td></tr>
<tr class="separator:ac03902ad8e261e0f9751b35ae04bdd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e73c55b78993e478ec28e9565abfe2" id="r_a03e73c55b78993e478ec28e9565abfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03e73c55b78993e478ec28e9565abfe2">addOption</a> (const std::string &amp;<a class="el" href="#adc1c8972e22012b23179f4eb4d771a82">option</a>, const std::string &amp;value)</td></tr>
<tr class="memdesc:a03e73c55b78993e478ec28e9565abfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add function specific options.  <br /></td></tr>
<tr class="separator:a03e73c55b78993e478ec28e9565abfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05eb2c2a808ab5b8578aa496827f531" id="r_ac05eb2c2a808ab5b8578aa496827f531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac05eb2c2a808ab5b8578aa496827f531">optionExists</a> (const std::string &amp;<a class="el" href="#adc1c8972e22012b23179f4eb4d771a82">option</a>) const</td></tr>
<tr class="memdesc:ac05eb2c2a808ab5b8578aa496827f531"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether an option exists  <br /></td></tr>
<tr class="separator:ac05eb2c2a808ab5b8578aa496827f531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d95631ca6b1b9687260520150ec19" id="r_adf5d95631ca6b1b9687260520150ec19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf5d95631ca6b1b9687260520150ec19">removeOption</a> (const std::string &amp;<a class="el" href="#adc1c8972e22012b23179f4eb4d771a82">option</a>)</td></tr>
<tr class="memdesc:adf5d95631ca6b1b9687260520150ec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an option if it exists.  <br /></td></tr>
<tr class="separator:adf5d95631ca6b1b9687260520150ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19fd8212c050a12ddbb9632e3ec154f" id="r_aa19fd8212c050a12ddbb9632e3ec154f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa19fd8212c050a12ddbb9632e3ec154f">optionValue</a> (const std::string &amp;<a class="el" href="#adc1c8972e22012b23179f4eb4d771a82">option</a>) const</td></tr>
<tr class="memdesc:aa19fd8212c050a12ddbb9632e3ec154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value corresponding to an option.  <br /></td></tr>
<tr class="separator:aa19fd8212c050a12ddbb9632e3ec154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c8972e22012b23179f4eb4d771a82" id="r_adc1c8972e22012b23179f4eb4d771a82"><td class="memItemLeft" align="right" valign="top"><a id="adc1c8972e22012b23179f4eb4d771a82" name="adc1c8972e22012b23179f4eb4d771a82"></a>
const std::map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>option</b> () const</td></tr>
<tr class="memdesc:adc1c8972e22012b23179f4eb4d771a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the options map. <br /></td></tr>
<tr class="separator:adc1c8972e22012b23179f4eb4d771a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31cb40aa31a0d346613f1d29001013e" id="r_ab31cb40aa31a0d346613f1d29001013e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab31cb40aa31a0d346613f1d29001013e">addCombinationRule</a> (const std::string &amp;param, const std::string &amp;rule)</td></tr>
<tr class="memdesc:ab31cb40aa31a0d346613f1d29001013e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add function specific combination rule.  <br /></td></tr>
<tr class="separator:ab31cb40aa31a0d346613f1d29001013e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dc82ca06b5b203f879f4034704d2ec" id="r_a15dc82ca06b5b203f879f4034704d2ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15dc82ca06b5b203f879f4034704d2ec">addCombinationRule</a> (const std::string &amp;param, const std::string &amp;rule, const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp;ffpl)</td></tr>
<tr class="memdesc:a15dc82ca06b5b203f879f4034704d2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add function specific combination rule.  <br /></td></tr>
<tr class="separator:a15dc82ca06b5b203f879f4034704d2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944bb0cb86b5979ed22bc841073d3d5b" id="r_a944bb0cb86b5979ed22bc841073d3d5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a944bb0cb86b5979ed22bc841073d3d5b">combinationRuleExists</a> (const std::string &amp;param) const</td></tr>
<tr class="memdesc:a944bb0cb86b5979ed22bc841073d3d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether a combination rule exists  <br /></td></tr>
<tr class="separator:a944bb0cb86b5979ed22bc841073d3d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0b44668967bd9d3caa27ff08246cc" id="r_addb0b44668967bd9d3caa27ff08246cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classalexandria_1_1ParamCombRule.xhtml">ParamCombRule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addb0b44668967bd9d3caa27ff08246cc">combinationRuleConst</a> (const std::string &amp;param) const</td></tr>
<tr class="memdesc:addb0b44668967bd9d3caa27ff08246cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the rule corresponding to a parameter.  <br /></td></tr>
<tr class="separator:addb0b44668967bd9d3caa27ff08246cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c865c306226d8e2ec01adfca7fbc5a" id="r_a82c865c306226d8e2ec01adfca7fbc5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexandria_1_1ParamCombRule.xhtml">ParamCombRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c865c306226d8e2ec01adfca7fbc5a">combinationRule</a> (const std::string &amp;param)</td></tr>
<tr class="memdesc:a82c865c306226d8e2ec01adfca7fbc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the rule corresponding to a parameter for editing.  <br /></td></tr>
<tr class="separator:a82c865c306226d8e2ec01adfca7fbc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29baf0cb3ad89de808dd49786c99a1" id="r_a4f29baf0cb3ad89de808dd49786c99a1"><td class="memItemLeft" align="right" valign="top"><a id="a4f29baf0cb3ad89de808dd49786c99a1" name="a4f29baf0cb3ad89de808dd49786c99a1"></a>
const <a class="el" href="namespacealexandria.xhtml#a2c083a8e2f1ccf8b736870c9b258ed9c">CombRuleSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>combinationRules</b> () const</td></tr>
<tr class="memdesc:a4f29baf0cb3ad89de808dd49786c99a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the combination rule map. <br /></td></tr>
<tr class="separator:a4f29baf0cb3ad89de808dd49786c99a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2dedc7182e93b2201c5d21d0f59fb3" id="r_aab2dedc7182e93b2201c5d21d0f59fb3"><td class="memItemLeft" align="right" valign="top"><a id="aab2dedc7182e93b2201c5d21d0f59fb3" name="aab2dedc7182e93b2201c5d21d0f59fb3"></a>
const <a class="el" href="namespacealexandria.xhtml#a57c16b7efa886d326640dd5790fde63a">ForceFieldParameterListMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>parametersConst</b> () const</td></tr>
<tr class="memdesc:aab2dedc7182e93b2201c5d21d0f59fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameters map as a const variable. <br /></td></tr>
<tr class="separator:aab2dedc7182e93b2201c5d21d0f59fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bff4f533682c47eda962e33022ecd7" id="r_a56bff4f533682c47eda962e33022ecd7"><td class="memItemLeft" align="right" valign="top"><a id="a56bff4f533682c47eda962e33022ecd7" name="a56bff4f533682c47eda962e33022ecd7"></a>
<a class="el" href="namespacealexandria.xhtml#a57c16b7efa886d326640dd5790fde63a">ForceFieldParameterListMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b> ()</td></tr>
<tr class="memdesc:a56bff4f533682c47eda962e33022ecd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parameters map as an editable variable. <br /></td></tr>
<tr class="separator:a56bff4f533682c47eda962e33022ecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf8270eccd2b293665a10ae562a97b5" id="r_afaf8270eccd2b293665a10ae562a97b5"><td class="memItemLeft" align="right" valign="top"><a id="afaf8270eccd2b293665a10ae562a97b5" name="afaf8270eccd2b293665a10ae562a97b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearParameters</b> ()</td></tr>
<tr class="memdesc:afaf8270eccd2b293665a10ae562a97b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parameter map. <br /></td></tr>
<tr class="separator:afaf8270eccd2b293665a10ae562a97b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d582c85aad51140400b6996c2dc2c35" id="r_a1d582c85aad51140400b6996c2dc2c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d582c85aad51140400b6996c2dc2c35">addParameter</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier, const std::string &amp;type, const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp;param)</td></tr>
<tr class="memdesc:a1d582c85aad51140400b6996c2dc2c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one parameter to the map.  <br /></td></tr>
<tr class="separator:a1d582c85aad51140400b6996c2dc2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff9dda65ddc6bfbe29b9e5f825a630d" id="r_acff9dda65ddc6bfbe29b9e5f825a630d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff9dda65ddc6bfbe29b9e5f825a630d">parameterExists</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier) const</td></tr>
<tr class="memdesc:acff9dda65ddc6bfbe29b9e5f825a630d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether any parameter exists for identifier  <br /></td></tr>
<tr class="separator:acff9dda65ddc6bfbe29b9e5f825a630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159f33126a4774a4bc263356be4115db" id="r_a159f33126a4774a4bc263356be4115db"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159f33126a4774a4bc263356be4115db">numberOfParameters</a> () const</td></tr>
<tr class="memdesc:a159f33126a4774a4bc263356be4115db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of parameters in this list.  <br /></td></tr>
<tr class="separator:a159f33126a4774a4bc263356be4115db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81032af3eb482c8a97daf89105350f01" id="r_a81032af3eb482c8a97daf89105350f01"><td class="memItemLeft" align="right" valign="top"><a id="a81032af3eb482c8a97daf89105350f01" name="a81032af3eb482c8a97daf89105350f01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a81032af3eb482c8a97daf89105350f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether or not there are any parameters <br /></td></tr>
<tr class="separator:a81032af3eb482c8a97daf89105350f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a595ea430a3b0a0e3580f2b65294042" id="r_a1a595ea430a3b0a0e3580f2b65294042"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a595ea430a3b0a0e3580f2b65294042">parameterId</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier) const</td></tr>
<tr class="memdesc:a1a595ea430a3b0a0e3580f2b65294042"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether any parameter exists for identifier  <br /></td></tr>
<tr class="separator:a1a595ea430a3b0a0e3580f2b65294042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bda5e0bc2aaed7d09686e9fb03ac71" id="r_aa0bda5e0bc2aaed7d09686e9fb03ac71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0bda5e0bc2aaed7d09686e9fb03ac71">findParameterMapConst</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier) const</td></tr>
<tr class="memdesc:aa0bda5e0bc2aaed7d09686e9fb03ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up map of parameters.  <br /></td></tr>
<tr class="separator:aa0bda5e0bc2aaed7d09686e9fb03ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4b281c7e2ef398ad77319822db192a" id="r_a5f4b281c7e2ef398ad77319822db192a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f4b281c7e2ef398ad77319822db192a">findParametersPtrConst</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier) const</td></tr>
<tr class="memdesc:a5f4b281c7e2ef398ad77319822db192a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find map of parameters for editing Will throw an exception when identifier is not found.  <br /></td></tr>
<tr class="separator:a5f4b281c7e2ef398ad77319822db192a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a103c33f14013faac2f8cbbb3a696" id="r_ac64a103c33f14013faac2f8cbbb3a696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac64a103c33f14013faac2f8cbbb3a696">findParameters</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier)</td></tr>
<tr class="memdesc:ac64a103c33f14013faac2f8cbbb3a696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find map of parameters for editing Will throw an exception when identifier is not found.  <br /></td></tr>
<tr class="separator:ac64a103c33f14013faac2f8cbbb3a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cea16e6cf1aeb674fb6b1ee4e330d7" id="r_a56cea16e6cf1aeb674fb6b1ee4e330d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56cea16e6cf1aeb674fb6b1ee4e330d7">findParameterTypeConst</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier, const std::string &amp;type) const</td></tr>
<tr class="memdesc:a56cea16e6cf1aeb674fb6b1ee4e330d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to look up specific parameter.  <br /></td></tr>
<tr class="separator:a56cea16e6cf1aeb674fb6b1ee4e330d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d9b7c2c308392a8ca4f93de7a3c474" id="r_a65d9b7c2c308392a8ca4f93de7a3c474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65d9b7c2c308392a8ca4f93de7a3c474">findParameterType</a> (const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;identifier, const std::string &amp;type)</td></tr>
<tr class="memdesc:a65d9b7c2c308392a8ca4f93de7a3c474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to look up specific parameter for editing.  <br /></td></tr>
<tr class="separator:a65d9b7c2c308392a8ca4f93de7a3c474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4925d0e036facd06a404cdbf7bb856" id="r_a1b4925d0e036facd06a404cdbf7bb856"><td class="memItemLeft" align="right" valign="top"><a id="a1b4925d0e036facd06a404cdbf7bb856" name="a1b4925d0e036facd06a404cdbf7bb856"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eraseParameter</b> ()</td></tr>
<tr class="memdesc:a1b4925d0e036facd06a404cdbf7bb856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parameter map. Used in bastat to rebuild the parameters. <br /></td></tr>
<tr class="separator:a1b4925d0e036facd06a404cdbf7bb856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef9ea473ec872817ab62c867ed59f25" id="r_a0ef9ea473ec872817ab62c867ed59f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ef9ea473ec872817ab62c867ed59f25">dump</a> (FILE *fp) const</td></tr>
<tr class="memdesc:a0ef9ea473ec872817ab62c867ed59f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump contents to a file.  <br /></td></tr>
<tr class="separator:a0ef9ea473ec872817ab62c867ed59f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac9323c0a586238de1038630fea1922" id="r_adac9323c0a586238de1038630fea1922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac9323c0a586238de1038630fea1922">Send</a> (const CommunicationRecord *cr, int dest) const</td></tr>
<tr class="memdesc:adac9323c0a586238de1038630fea1922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the contents to another processor.  <br /></td></tr>
<tr class="separator:adac9323c0a586238de1038630fea1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab968f912c22ecc9800e75fc69605d775" id="r_ab968f912c22ecc9800e75fc69605d775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab968f912c22ecc9800e75fc69605d775">BroadCast</a> (const CommunicationRecord *cr, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:ab968f912c22ecc9800e75fc69605d775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast contents from another processor.  <br /></td></tr>
<tr class="separator:ab968f912c22ecc9800e75fc69605d775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2cc6f89bce3194bd264dbece9780db" id="r_a1d2cc6f89bce3194bd264dbece9780db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d2cc6f89bce3194bd264dbece9780db">Receive</a> (const CommunicationRecord *cr, int src)</td></tr>
<tr class="memdesc:a1d2cc6f89bce3194bd264dbece9780db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive contents from another processor.  <br /></td></tr>
<tr class="separator:a1d2cc6f89bce3194bd264dbece9780db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612efe781957d9154072795c0333a70d" id="r_a612efe781957d9154072795c0333a70d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612efe781957d9154072795c0333a70d">counter</a> () const</td></tr>
<tr class="separator:a612efe781957d9154072795c0333a70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7933e2e5943dd2f1a125cd9dd8b4d54c" name="a7933e2e5943dd2f1a125cd9dd8b4d54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7933e2e5943dd2f1a125cd9dd8b4d54c">&#9670;&#160;</a></span>ForceFieldParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">alexandria::ForceFieldParameterList::ForceFieldParameterList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexandria.xhtml#a35774efb4237acf884386e0292d213ab">CanSwap</a></td>          <td class="paramname"><span class="paramname"><em>canSwap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function for which parameters are stored. This may be an empty variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">canSwap</td><td>Can atom/bond identifiers be swapped in order </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>function is not recognized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab31cb40aa31a0d346613f1d29001013e" name="ab31cb40aa31a0d346613f1d29001013e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31cb40aa31a0d346613f1d29001013e">&#9670;&#160;</a></span>addCombinationRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::addCombinationRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rule</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add function specific combination rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Name of the parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>String for the rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15dc82ca06b5b203f879f4034704d2ec" name="a15dc82ca06b5b203f879f4034704d2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dc82ca06b5b203f879f4034704d2ec">&#9670;&#160;</a></span>addCombinationRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::addCombinationRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rule</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ffpl</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add function specific combination rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Name of the parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>String for the rule </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ffpl</td><td>Parameter used for GeneralizedMean only </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03e73c55b78993e478ec28e9565abfe2" name="a03e73c55b78993e478ec28e9565abfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e73c55b78993e478ec28e9565abfe2">&#9670;&#160;</a></span>addOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::addOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add function specific options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Name of the option </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the opton </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d582c85aad51140400b6996c2dc2c35" name="a1d582c85aad51140400b6996c2dc2c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d582c85aad51140400b6996c2dc2c35">&#9670;&#160;</a></span>addParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::addParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add one parameter to the map. </p>
<p>Add one parameter for the given identifier (e.g. atomtype or bond). If the parameter type has been set already an exception will be raised (this check has not been implemented yet). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the atomtype or bond </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The parameter type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>The force field parameter structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab968f912c22ecc9800e75fc69605d775" name="ab968f912c22ecc9800e75fc69605d775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab968f912c22ecc9800e75fc69605d775">&#9670;&#160;</a></span>BroadCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ForceFieldParameterList::BroadCast </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast contents from another processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The MPI root </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI communication structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the whole thing </dd></dl>

</div>
</div>
<a id="a82c865c306226d8e2ec01adfca7fbc5a" name="a82c865c306226d8e2ec01adfca7fbc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c865c306226d8e2ec01adfca7fbc5a">&#9670;&#160;</a></span>combinationRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexandria_1_1ParamCombRule.xhtml">ParamCombRule</a> * alexandria::ForceFieldParameterList::combinationRule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the rule corresponding to a parameter for editing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Name of the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">gmx::InvalidInputError</td><td>if the param is non-existent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addb0b44668967bd9d3caa27ff08246cc" name="addb0b44668967bd9d3caa27ff08246cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb0b44668967bd9d3caa27ff08246cc">&#9670;&#160;</a></span>combinationRuleConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classalexandria_1_1ParamCombRule.xhtml">ParamCombRule</a> &amp; alexandria::ForceFieldParameterList::combinationRuleConst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the rule corresponding to a parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Name of the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">gmx::InvalidInputError</td><td>if the param is non-existent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a944bb0cb86b5979ed22bc841073d3d5b" name="a944bb0cb86b5979ed22bc841073d3d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944bb0cb86b5979ed22bc841073d3d5b">&#9670;&#160;</a></span>combinationRuleExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ForceFieldParameterList::combinationRuleExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether a combination rule exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Name of the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool value </dd></dl>

</div>
</div>
<a id="a612efe781957d9154072795c0333a70d" name="a612efe781957d9154072795c0333a70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612efe781957d9154072795c0333a70d">&#9670;&#160;</a></span>counter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int alexandria::ForceFieldParameterList::counter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The counter <code class="param">counter_</code> for index </dd></dl>

</div>
</div>
<a id="a0ef9ea473ec872817ab62c867ed59f25" name="a0ef9ea473ec872817ab62c867ed59f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef9ea473ec872817ab62c867ed59f25">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::dump </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump contents to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>File pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0bda5e0bc2aaed7d09686e9fb03ac71" name="aa0bda5e0bc2aaed7d09686e9fb03ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bda5e0bc2aaed7d09686e9fb03ac71">&#9670;&#160;</a></span>findParameterMapConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> &amp; alexandria::ForceFieldParameterList::findParameterMapConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up map of parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the atomtype or bond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of parameters that maybe empty if not found </dd></dl>

</div>
</div>
<a id="ac64a103c33f14013faac2f8cbbb3a696" name="ac64a103c33f14013faac2f8cbbb3a696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a103c33f14013faac2f8cbbb3a696">&#9670;&#160;</a></span>findParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> * alexandria::ForceFieldParameterList::findParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find map of parameters for editing Will throw an exception when identifier is not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the atomtype or bond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of parameters </dd></dl>

</div>
</div>
<a id="a5f4b281c7e2ef398ad77319822db192a" name="a5f4b281c7e2ef398ad77319822db192a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4b281c7e2ef398ad77319822db192a">&#9670;&#160;</a></span>findParametersPtrConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacealexandria.xhtml#a422f6144f44851e83e63d6a2fa0d6d9e">ForceFieldParameterMap</a> * alexandria::ForceFieldParameterList::findParametersPtrConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find map of parameters for editing Will throw an exception when identifier is not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the atomtype or bond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of parameters </dd></dl>

</div>
</div>
<a id="a65d9b7c2c308392a8ca4f93de7a3c474" name="a65d9b7c2c308392a8ca4f93de7a3c474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d9b7c2c308392a8ca4f93de7a3c474">&#9670;&#160;</a></span>findParameterType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> * alexandria::ForceFieldParameterList::findParameterType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to look up specific parameter for editing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>String with atoms or bonds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The parameter type, e.g. sigma or bondlength </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56cea16e6cf1aeb674fb6b1ee4e330d7" name="a56cea16e6cf1aeb674fb6b1ee4e330d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cea16e6cf1aeb674fb6b1ee4e330d7">&#9670;&#160;</a></span>findParameterTypeConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classalexandria_1_1ForceFieldParameter.xhtml">ForceFieldParameter</a> &amp; alexandria::ForceFieldParameterList::findParameterTypeConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to look up specific parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>String with atoms or bonds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The parameter type, e.g. sigma or bondlength </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a159f33126a4774a4bc263356be4115db" name="a159f33126a4774a4bc263356be4115db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159f33126a4774a4bc263356be4115db">&#9670;&#160;</a></span>numberOfParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t alexandria::ForceFieldParameterList::numberOfParameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of parameters in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>number of parameters </dd></dl>

</div>
</div>
<a id="ac05eb2c2a808ab5b8578aa496827f531" name="ac05eb2c2a808ab5b8578aa496827f531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05eb2c2a808ab5b8578aa496827f531">&#9670;&#160;</a></span>optionExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ForceFieldParameterList::optionExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>option</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether an option exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Name of the option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool value </dd></dl>

</div>
</div>
<a id="aa19fd8212c050a12ddbb9632e3ec154f" name="aa19fd8212c050a12ddbb9632e3ec154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19fd8212c050a12ddbb9632e3ec154f">&#9670;&#160;</a></span>optionValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; alexandria::ForceFieldParameterList::optionValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>option</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the value corresponding to an option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Name of the option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">gmx::InvalidInputError</td><td>if the option is non-existent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acff9dda65ddc6bfbe29b9e5f825a630d" name="acff9dda65ddc6bfbe29b9e5f825a630d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff9dda65ddc6bfbe29b9e5f825a630d">&#9670;&#160;</a></span>parameterExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ForceFieldParameterList::parameterExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether any parameter exists for identifier </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the bond or atomtype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool value </dd></dl>

</div>
</div>
<a id="a1a595ea430a3b0a0e3580f2b65294042" name="a1a595ea430a3b0a0e3580f2b65294042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a595ea430a3b0a0e3580f2b65294042">&#9670;&#160;</a></span>parameterId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t alexandria::ForceFieldParameterList::parameterId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1Identifier.xhtml">Identifier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>identifier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether any parameter exists for identifier </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">identifier</td><td>Name of the bond or atomtype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parameter index </dd></dl>

</div>
</div>
<a id="a1d2cc6f89bce3194bd264dbece9780db" name="a1d2cc6f89bce3194bd264dbece9780db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2cc6f89bce3194bd264dbece9780db">&#9670;&#160;</a></span>Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ForceFieldParameterList::Receive </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive contents from another processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Processor id to receive the data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf5d95631ca6b1b9687260520150ec19" name="adf5d95631ca6b1b9687260520150ec19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d95631ca6b1b9687260520150ec19">&#9670;&#160;</a></span>removeOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ForceFieldParameterList::removeOption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>option</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an option if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Name of the option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac9323c0a586238de1038630fea1922" name="adac9323c0a586238de1038630fea1922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac9323c0a586238de1038630fea1922">&#9670;&#160;</a></span>Send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ForceFieldParameterList::Send </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the contents to another processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>Communication data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Processor id to send the data to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/act/forcefield/<b>forcefield_parameterlist.h</b></li>
<li>src/act/forcefield/<b>forcefield_parameterlist.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacealexandria.xhtml">alexandria</a></li><li class="navelem"><a class="el" href="classalexandria_1_1ForceFieldParameterList.xhtml">ForceFieldParameterList</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
