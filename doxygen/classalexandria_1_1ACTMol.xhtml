<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACT: alexandria::ACTMol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACT
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.xhtml');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classalexandria_1_1ACTMol.xhtml',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classalexandria_1_1ACTMol-members.xhtml">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">alexandria::ACTMol Class Reference<div class="ingroups"><a class="el" href="group__group__publicapi.xhtml">Public API</a> &#124; <a class="el" href="group__module__alexandria.xhtml">Code related to ACT in general</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;act/alexandria/actmol.h&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for alexandria::ACTMol:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classalexandria_1_1ACTMol__inherit__graph.svg" width="163" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.xhtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for alexandria::ACTMol:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classalexandria_1_1ACTMol__coll__graph.svg" width="163" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.xhtml">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Contains molecular properties from a range of sources. Overloads the regular molprop and adds a lot of functionality. For one thing, it can generate molprop contents from a coordinate file if needed. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8a7bc0c48519cd4c9cf0116430d35a79" id="r_a8a7bc0c48519cd4c9cf0116430d35a79"><td class="memItemLeft" align="right" valign="top">const real *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a7bc0c48519cd4c9cf0116430d35a79">energyTerms</a> () const</td></tr>
<tr class="separator:a8a7bc0c48519cd4c9cf0116430d35a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e5d685c2f4794218234c4f75031922" id="r_a63e5d685c2f4794218234c4f75031922"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gmx::RVec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e5d685c2f4794218234c4f75031922">xOriginal</a> () const</td></tr>
<tr class="memdesc:a63e5d685c2f4794218234c4f75031922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a coordinate vector of the molecule corresponding to the first experiment with Jobtype Opt or Topology or SP. The array includes shells and/or vsites.  <br /></td></tr>
<tr class="separator:a63e5d685c2f4794218234c4f75031922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931b963ecbafa452205bf19432ce005c" id="r_a931b963ecbafa452205bf19432ce005c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gmx::RVec &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a931b963ecbafa452205bf19432ce005c">experCoords</a> (const std::vector&lt; gmx::RVec &gt; &amp;xxx) const</td></tr>
<tr class="memdesc:a931b963ecbafa452205bf19432ce005c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a modified coordinate vector of the molecule based on the input. The output array includes shells and/or vsites.  <br /></td></tr>
<tr class="separator:a931b963ecbafa452205bf19432ce005c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52d915e56e769d7563838d3ea83dfe3" id="r_af52d915e56e769d7563838d3ea83dfe3"><td class="memItemLeft" align="right" valign="top"><a id="af52d915e56e769d7563838d3ea83dfe3" name="af52d915e56e769d7563838d3ea83dfe3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ACTMol</b> ()</td></tr>
<tr class="memdesc:af52d915e56e769d7563838d3ea83dfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:af52d915e56e769d7563838d3ea83dfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2867c7e8ce65abe45a6e58a0675b8c5" id="r_ae2867c7e8ce65abe45a6e58a0675b8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexandria_1_1MolProp.xhtml">MolProp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2867c7e8ce65abe45a6e58a0675b8c5">molProp</a> ()</td></tr>
<tr class="separator:ae2867c7e8ce65abe45a6e58a0675b8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd854b8de8f4c44f6b0622758f3bca2f" id="r_abd854b8de8f4c44f6b0622758f3bca2f"><td class="memItemLeft" align="right" valign="top">iMolSelect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd854b8de8f4c44f6b0622758f3bca2f">datasetType</a> () const</td></tr>
<tr class="separator:abd854b8de8f4c44f6b0622758f3bca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb0fb9d2221a003eef738f36499358" id="r_a9bcb0fb9d2221a003eef738f36499358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bcb0fb9d2221a003eef738f36499358">set_datasetType</a> (iMolSelect dataset_type)</td></tr>
<tr class="memdesc:a9bcb0fb9d2221a003eef738f36499358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the dataset type.  <br /></td></tr>
<tr class="separator:a9bcb0fb9d2221a003eef738f36499358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782be3898bfee12792bb636c2280f96e" id="r_a782be3898bfee12792bb636c2280f96e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a782be3898bfee12792bb636c2280f96e">jobType</a> () const</td></tr>
<tr class="separator:a782be3898bfee12792bb636c2280f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1031d997ba139fc7b19af13daf4bbd" id="r_a3f1031d997ba139fc7b19af13daf4bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1031d997ba139fc7b19af13daf4bbd">haveShells</a> () const</td></tr>
<tr class="separator:a3f1031d997ba139fc7b19af13daf4bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e6379bc12c4c7fa86dee5bf430398" id="r_abc7e6379bc12c4c7fa86dee5bf430398"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7e6379bc12c4c7fa86dee5bf430398">linearMolecule</a> () const</td></tr>
<tr class="separator:abc7e6379bc12c4c7fa86dee5bf430398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac361cdb7aa60429f5d5c27c98a874257" id="r_ac361cdb7aa60429f5d5c27c98a874257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexandria.xhtml#a8be9254d6f9b31942d8fc30f78af14ef">eSupport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac361cdb7aa60429f5d5c27c98a874257">support</a> () const</td></tr>
<tr class="separator:ac361cdb7aa60429f5d5c27c98a874257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783bbb2b72721c53db5ecc021458eec" id="r_aa783bbb2b72721c53db5ecc021458eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa783bbb2b72721c53db5ecc021458eec">setSupport</a> (<a class="el" href="namespacealexandria.xhtml#a8be9254d6f9b31942d8fc30f78af14ef">eSupport</a> esup)</td></tr>
<tr class="memdesc:aa783bbb2b72721c53db5ecc021458eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the support type.  <br /></td></tr>
<tr class="separator:aa783bbb2b72721c53db5ecc021458eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415132d468f2cfc296de9c484f310a2a" id="r_a415132d468f2cfc296de9c484f310a2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415132d468f2cfc296de9c484f310a2a">nRealAtoms</a> () const</td></tr>
<tr class="separator:a415132d468f2cfc296de9c484f310a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c64a56f62d58701578b47db5f16c8" id="r_ab55c64a56f62d58701578b47db5f16c8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab55c64a56f62d58701578b47db5f16c8">realAtoms</a> () const</td></tr>
<tr class="separator:ab55c64a56f62d58701578b47db5f16c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ade008e59340775b9cc2fd6fd09cb5" id="r_aa8ade008e59340775b9cc2fd6fd09cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8ade008e59340775b9cc2fd6fd09cb5">energy</a> (<a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a> mpo, double *ener) const</td></tr>
<tr class="separator:aa8ade008e59340775b9cc2fd6fd09cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d45938656c86aa4551271071a2e8ed" id="r_a97d45938656c86aa4551271071a2e8ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97d45938656c86aa4551271071a2e8ed">forceEnergyMaps</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, std::vector&lt; std::vector&lt; std::pair&lt; double, double &gt; &gt; &gt; *forceMap, std::vector&lt; <a class="el" href="classalexandria_1_1ACTEnergy.xhtml">ACTEnergy</a> &gt; *energyMap, <a class="el" href="namespacealexandria.xhtml#a5f41c3a634b231705347c9cc55d2a6d3">ACTEnergyMapVector</a> *interactionEnergyMap, std::vector&lt; std::pair&lt; double, std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; &gt; &gt; *energyComponentMap, bool separateInductionCorrection) const</td></tr>
<tr class="memdesc:a97d45938656c86aa4551271071a2e8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute energies and forces for all structures The optimized structure as well as all the excited structures will be used to compute the energy and forces. Store the results in vectors containing two doubles, first the reference, then the calculated one. Forces are stored as a vector of structures and then a vector of atoms. Energies are stored as a 1D vector pair. All energy components are stored as a vector of reference energies paired with a map of ACT energy components. The <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74" title="Interaction type.">InteractionType</a> index points to the energy type in the energyComponentsMap.  <br /></td></tr>
<tr class="separator:a97d45938656c86aa4551271071a2e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b3a75a05ef53186e13e8036ecda54" id="r_a573b3a75a05ef53186e13e8036ecda54"><td class="memItemLeft" align="right" valign="top"><a id="a573b3a75a05ef53186e13e8036ecda54" name="a573b3a75a05ef53186e13e8036ecda54"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>referenceFrequencies</b> () const</td></tr>
<tr class="memdesc:a573b3a75a05ef53186e13e8036ecda54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference frequencies collected earlier. <br /></td></tr>
<tr class="separator:a573b3a75a05ef53186e13e8036ecda54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e0bde64edd612388512cbfa0487c2b" id="r_ab8e0bde64edd612388512cbfa0487c2b"><td class="memItemLeft" align="right" valign="top"><a id="ab8e0bde64edd612388512cbfa0487c2b" name="ab8e0bde64edd612388512cbfa0487c2b"></a>
const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>referenceIntensities</b> () const</td></tr>
<tr class="memdesc:ab8e0bde64edd612388512cbfa0487c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference intensities collected earlier. <br /></td></tr>
<tr class="separator:ab8e0bde64edd612388512cbfa0487c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36234276426a845b9515e59946ef0592" id="r_a36234276426a845b9515e59946ef0592"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ActAtom &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36234276426a845b9515e59946ef0592">atoms</a> ()</td></tr>
<tr class="separator:a36234276426a845b9515e59946ef0592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793e33843cc0e960ad5e8a407d54c8cd" id="r_a793e33843cc0e960ad5e8a407d54c8cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; ActAtom &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a793e33843cc0e960ad5e8a407d54c8cd">atomsConst</a> ()</td></tr>
<tr class="separator:a793e33843cc0e960ad5e8a407d54c8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e462e0b7272d7276d61bde48974ee1" id="r_a33e462e0b7272d7276d61bde48974ee1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classalexandria_1_1ACTQprop.xhtml">ACTQprop</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e462e0b7272d7276d61bde48974ee1">qProps</a> ()</td></tr>
<tr class="separator:a33e462e0b7272d7276d61bde48974ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c54cbe0c5b9f903cf235434c14f1e4" id="r_ad6c54cbe0c5b9f903cf235434c14f1e4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classalexandria_1_1ACTQprop.xhtml">ACTQprop</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6c54cbe0c5b9f903cf235434c14f1e4">qPropsConst</a> () const</td></tr>
<tr class="separator:ad6c54cbe0c5b9f903cf235434c14f1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dff908d8be0c3cc692f665eb4536b6" id="r_ac2dff908d8be0c3cc692f665eb4536b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2dff908d8be0c3cc692f665eb4536b6">levelOfTheory</a> ()</td></tr>
<tr class="separator:ac2dff908d8be0c3cc692f665eb4536b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b4019ff7edc71d72738bccf08b2dff" id="r_ad6b4019ff7edc71d72738bccf08b2dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6b4019ff7edc71d72738bccf08b2dff">setBasisset</a> (const std::string &amp;basis)</td></tr>
<tr class="memdesc:ad6b4019ff7edc71d72738bccf08b2dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set QM basis set.  <br /></td></tr>
<tr class="separator:ad6b4019ff7edc71d72738bccf08b2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0440b97826f2d776cbe0d1b37b4cb571" id="r_a0440b97826f2d776cbe0d1b37b4cb571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0440b97826f2d776cbe0d1b37b4cb571">setMethod</a> (const std::string &amp;method)</td></tr>
<tr class="memdesc:a0440b97826f2d776cbe0d1b37b4cb571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set QM method.  <br /></td></tr>
<tr class="separator:a0440b97826f2d776cbe0d1b37b4cb571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437c500792a8ea59a14479a3e7cf7775" id="r_a437c500792a8ea59a14479a3e7cf7775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437c500792a8ea59a14479a3e7cf7775">hasMolPropObservable</a> (<a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a> mpo) const</td></tr>
<tr class="separator:a437c500792a8ea59a14479a3e7cf7775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004badc910ffa62370997d95c18b6c7d" id="r_a004badc910ffa62370997d95c18b6c7d"><td class="memItemLeft" align="right" valign="top"><a id="a004badc910ffa62370997d95c18b6c7d" name="a004badc910ffa62370997d95c18b6c7d"></a>
<a class="el" href="classalexandria_1_1FragmentHandler.xhtml">FragmentHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fragmentHandler</b> ()</td></tr>
<tr class="memdesc:a004badc910ffa62370997d95c18b6c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fragment handler. <br /></td></tr>
<tr class="separator:a004badc910ffa62370997d95c18b6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a346d577babe12e52756f5d398d247" id="r_ac5a346d577babe12e52756f5d398d247"><td class="memItemLeft" align="right" valign="top"><a id="ac5a346d577babe12e52756f5d398d247" name="ac5a346d577babe12e52756f5d398d247"></a>
const <a class="el" href="classalexandria_1_1FragmentHandler.xhtml">FragmentHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fragmentHandler</b> () const</td></tr>
<tr class="memdesc:ac5a346d577babe12e52756f5d398d247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fragment handler. <br /></td></tr>
<tr class="separator:ac5a346d577babe12e52756f5d398d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c7484e07835bfc311bb9c02de3b667" id="r_a08c7484e07835bfc311bb9c02de3b667"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; ActAtom &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c7484e07835bfc311bb9c02de3b667">atomsConst</a> () const</td></tr>
<tr class="separator:a08c7484e07835bfc311bb9c02de3b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c09ff912332fd2ec7e6e6fae49f849" id="r_a82c09ff912332fd2ec7e6e6fae49f849"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82c09ff912332fd2ec7e6e6fae49f849">bondOrder</a> (int ai, int aj) const</td></tr>
<tr class="memdesc:a82c09ff912332fd2ec7e6e6fae49f849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bond order.  <br /></td></tr>
<tr class="separator:a82c09ff912332fd2ec7e6e6fae49f849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0700ebe07e49fdccc5450ea333d7649a" id="r_a0700ebe07e49fdccc5450ea333d7649a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0700ebe07e49fdccc5450ea333d7649a">GenerateTopology</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, ForceField *pd, <a class="el" href="namespacealexandria.xhtml#afea33eb2c3ea5c817c514a01bda7320c">missingParameters</a> missing)</td></tr>
<tr class="memdesc:a0700ebe07e49fdccc5450ea333d7649a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It generates the atoms structure which will be used to print the topology file.  <br /></td></tr>
<tr class="separator:a0700ebe07e49fdccc5450ea333d7649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db8c49dd7c6552300b1e097683a8c1e" id="r_a2db8c49dd7c6552300b1e097683a8c1e"><td class="memItemLeft" align="right" valign="top"><a id="a2db8c49dd7c6552300b1e097683a8c1e" name="a2db8c49dd7c6552300b1e097683a8c1e"></a>
const Topology *&#160;</td><td class="memItemRight" valign="bottom"><b>topology</b> () const</td></tr>
<tr class="memdesc:a2db8c49dd7c6552300b1e097683a8c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ACT topology structure. <br /></td></tr>
<tr class="separator:a2db8c49dd7c6552300b1e097683a8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be09ee4f7020ca0d35116f5208b70f4" id="r_a4be09ee4f7020ca0d35116f5208b70f4"><td class="memItemLeft" align="right" valign="top"><a id="a4be09ee4f7020ca0d35116f5208b70f4" name="a4be09ee4f7020ca0d35116f5208b70f4"></a>
Topology *&#160;</td><td class="memItemRight" valign="bottom"><b>topologyPtr</b> ()</td></tr>
<tr class="memdesc:a4be09ee4f7020ca0d35116f5208b70f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ACT topology structure for editing. <br /></td></tr>
<tr class="separator:a4be09ee4f7020ca0d35116f5208b70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95e71ce504e215f6e099187ceed58cb" id="r_ad95e71ce504e215f6e099187ceed58cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad95e71ce504e215f6e099187ceed58cb">updateQprops</a> (const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, std::vector&lt; gmx::RVec &gt; *forces)</td></tr>
<tr class="memdesc:ad95e71ce504e215f6e099187ceed58cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update internal structures with electric moments etc.  <br /></td></tr>
<tr class="separator:ad95e71ce504e215f6e099187ceed58cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb34c870c16f52e1d92bd8783b86a5da" id="r_aeb34c870c16f52e1d92bd8783b86a5da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb34c870c16f52e1d92bd8783b86a5da">minimizeShells</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, std::vector&lt; gmx::RVec &gt; *coords, std::vector&lt; gmx::RVec &gt; *forces)</td></tr>
<tr class="memdesc:aeb34c870c16f52e1d92bd8783b86a5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize shell positions.  <br /></td></tr>
<tr class="separator:aeb34c870c16f52e1d92bd8783b86a5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bd736428b2a277c4b1de62b07dafa" id="r_a819bd736428b2a277c4b1de62b07dafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819bd736428b2a277c4b1de62b07dafa">setCharges</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const ForceField *pd, const std::string &amp;qread)</td></tr>
<tr class="memdesc:a819bd736428b2a277c4b1de62b07dafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy charges from input (molprop)  <br /></td></tr>
<tr class="separator:a819bd736428b2a277c4b1de62b07dafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86ae0eab237769260f3dc1a68cbf0a8" id="r_aa86ae0eab237769260f3dc1a68cbf0a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa86ae0eab237769260f3dc1a68cbf0a8">setCharges</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const ForceField *pd)</td></tr>
<tr class="memdesc:aa86ae0eab237769260f3dc1a68cbf0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy charges from force field to topologies.  <br /></td></tr>
<tr class="separator:aa86ae0eab237769260f3dc1a68cbf0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6677e0f0b685e22beffbf47562f976" id="r_a8c6677e0f0b685e22beffbf47562f976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c6677e0f0b685e22beffbf47562f976">setCharges</a> (const std::vector&lt; double &gt; &amp;qcustom)</td></tr>
<tr class="memdesc:a8c6677e0f0b685e22beffbf47562f976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy charges from array to topologies.  <br /></td></tr>
<tr class="separator:a8c6677e0f0b685e22beffbf47562f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40af35d63aa2dd4bc892eb269a150245" id="r_a40af35d63aa2dd4bc892eb269a150245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40af35d63aa2dd4bc892eb269a150245">setCharges</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const <a class="el" href="namespacealexandria.xhtml#a56446590bd6167854d1b3462215b10b0">ChargeMap</a> &amp;qmap)</td></tr>
<tr class="memdesc:a40af35d63aa2dd4bc892eb269a150245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy charges from qmap to topologies.  <br /></td></tr>
<tr class="separator:a40af35d63aa2dd4bc892eb269a150245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69756ff92778bbb9d1f7377e05f20997" id="r_a69756ff92778bbb9d1f7377e05f20997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69756ff92778bbb9d1f7377e05f20997">generateCharges</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, <a class="el" href="group__module__alexandria.xhtml#ga0420bcd6e71d174f3360e37de2bd9f63">ChargeGenerationAlgorithm</a> algorithm, std::vector&lt; gmx::RVec &gt; *coords, std::vector&lt; gmx::RVec &gt; *forces, bool updateQProps=false)</td></tr>
<tr class="memdesc:a69756ff92778bbb9d1f7377e05f20997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate or copy atomic partial charges.  <br /></td></tr>
<tr class="separator:a69756ff92778bbb9d1f7377e05f20997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981bda40721a2add528c8678e775dd85" id="r_a981bda40721a2add528c8678e775dd85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexandria.xhtml#aa30e28974e4670e2e6637f1e25114a18">ACTMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981bda40721a2add528c8678e775dd85">GenerateAcmCharges</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msg_handler, ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, std::vector&lt; gmx::RVec &gt; *coords, std::vector&lt; gmx::RVec &gt; *forces)</td></tr>
<tr class="memdesc:a981bda40721a2add528c8678e775dd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate atomic partial charges using EEM or SQE. If shells are present they will be minimized.  <br /></td></tr>
<tr class="separator:a981bda40721a2add528c8678e775dd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d874e4a90aeef2e7afb2cad3ae824cc" id="r_a5d874e4a90aeef2e7afb2cad3ae824cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d874e4a90aeef2e7afb2cad3ae824cc">getExpProps</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, ForceField *pd, const std::map&lt; <a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a>, <a class="el" href="group__group__molprop.xhtml#ga672ac03ebb5c06d86e7e44fe27ee8421">iqmType</a> &gt; &amp;iqm, real watoms=0, int maxESP=100)</td></tr>
<tr class="memdesc:a5d874e4a90aeef2e7afb2cad3ae824cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the properties from QM (Optimized structure) or from experiment.  <br /></td></tr>
<tr class="separator:a5d874e4a90aeef2e7afb2cad3ae824cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab9193c798febaa15ffdf606e38435" id="r_a1fab9193c798febaa15ffdf606e38435"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fab9193c798febaa15ffdf606e38435">generateCommercials</a> (const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, const std::vector&lt; gmx::RVec &gt; &amp;coords)</td></tr>
<tr class="memdesc:a1fab9193c798febaa15ffdf606e38435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate molecule info.  <br /></td></tr>
<tr class="separator:a1fab9193c798febaa15ffdf606e38435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ee9ee60e6b0ed7dc8a0ba160310f01" id="r_a93ee9ee60e6b0ed7dc8a0ba160310f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93ee9ee60e6b0ed7dc8a0ba160310f01">PrintTopology</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msg_handler, const char *fn, const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, const std::vector&lt; gmx::RVec &gt; &amp;coords, bool bITP=false)</td></tr>
<tr class="memdesc:a93ee9ee60e6b0ed7dc8a0ba160310f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the topology that was generated previously in GROMACS format.  <br /></td></tr>
<tr class="separator:a93ee9ee60e6b0ed7dc8a0ba160310f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2a309bd9813ea7225ca99febf247e7" id="r_aac2a309bd9813ea7225ca99febf247e7"><td class="memItemLeft" align="right" valign="top"><a id="aac2a309bd9813ea7225ca99febf247e7" name="aac2a309bd9813ea7225ca99febf247e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateMDAtoms</b> ()</td></tr>
<tr class="memdesc:aac2a309bd9813ea7225ca99febf247e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update GROMACS data structures. <br /></td></tr>
<tr class="separator:aac2a309bd9813ea7225ca99febf247e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd80b30685e6056794ff5bc9d461835" id="r_a6dd80b30685e6056794ff5bc9d461835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacealexandria.xhtml#aa30e28974e4670e2e6637f1e25114a18">ACTMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd80b30685e6056794ff5bc9d461835">calculateEnergyOld</a> (const t_commrec *crtmp, std::vector&lt; gmx::RVec &gt; *coordinates, PaddedVector&lt; gmx::RVec &gt; *forces, std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; *energies, real *shellForceRMS)</td></tr>
<tr class="memdesc:a6dd80b30685e6056794ff5bc9d461835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the forces and energies For a polarizable model the shell positions are minimized. This code is maintained only for comparing ACT native energies and forces to the gromacs code. Do not use in production code.  <br /></td></tr>
<tr class="separator:a6dd80b30685e6056794ff5bc9d461835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28422257a8694767a7ffc5163e9a60a3" id="r_a28422257a8694767a7ffc5163e9a60a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28422257a8694767a7ffc5163e9a60a3">calculateInteractionEnergy</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, const ForceField *pd, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComputer, std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; *einter, std::vector&lt; gmx::RVec &gt; *interactionForces, std::vector&lt; gmx::RVec &gt; *coords, bool separateInductionCorrection) const</td></tr>
<tr class="memdesc:a28422257a8694767a7ffc5163e9a60a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the interaction energies. For a system with multiple fragments this will compute Epot(system) - Sum_f Epot(f) where f are the fragments. Importantly the individual components of the energy are stored. For a polarizable model the shell positions are minimized.  <br /></td></tr>
<tr class="separator:a28422257a8694767a7ffc5163e9a60a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c491a3ff6e7d07d2f3a65e873c50793" id="r_a2c491a3ff6e7d07d2f3a65e873c50793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c491a3ff6e7d07d2f3a65e873c50793">UpdateIdef</a> (const ForceField *pd, const std::vector&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a> &gt; &amp;iTypes, bool updateZeta)</td></tr>
<tr class="memdesc:a2c491a3ff6e7d07d2f3a65e873c50793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update internal structures for bondtype due to changes in pd.  <br /></td></tr>
<tr class="separator:a2c491a3ff6e7d07d2f3a65e873c50793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d05937a09cb7be6c974ad2d05f3dd" id="r_a8a7d05937a09cb7be6c974ad2d05f3dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a7d05937a09cb7be6c974ad2d05f3dd">GenerateCube</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msghandler, ForceField *pd, const std::vector&lt; gmx::RVec &gt; &amp;coords, const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *forceComp, real spacing, real border, const char *reffn, const char *pcfn, const char *pdbdifffn, const char *potfn, const char *rhofn, const char *hisfn, const char *difffn, const char *diffhistfn, const gmx_output_env_t *oenv)</td></tr>
<tr class="memdesc:a8a7d05937a09cb7be6c974ad2d05f3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate cube.  <br /></td></tr>
<tr class="separator:a8a7d05937a09cb7be6c974ad2d05f3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97f86de88712861cd06c2735c4630e0" id="r_ac97f86de88712861cd06c2735c4630e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac97f86de88712861cd06c2735c4630e0">PrintConformation</a> (const char *fn, const std::vector&lt; gmx::RVec &gt; &amp;coords, bool writeShells, const matrix box)</td></tr>
<tr class="memdesc:ac97f86de88712861cd06c2735c4630e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the coordinates corresponding to topology after adding shell particles and/or vsites.  <br /></td></tr>
<tr class="separator:ac97f86de88712861cd06c2735c4630e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15cfbae019968fa3b3e3ffe80735a8e" id="r_ae15cfbae019968fa3b3e3ffe80735a8e"><td class="memItemLeft" align="right" valign="top"><a id="ae15cfbae019968fa3b3e3ffe80735a8e" name="ae15cfbae019968fa3b3e3ffe80735a8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classalexandria_1_1ACTMol.xhtml">ACTMol</a> &amp;mol) const</td></tr>
<tr class="memdesc:ae15cfbae019968fa3b3e3ffe80735a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal operator for <a class="el" href="classalexandria_1_1ACTMol.xhtml" title="Contains molecular properties from a range of sources. Overloads the regular molprop and adds a lot o...">ACTMol</a> object. <br /></td></tr>
<tr class="separator:ae15cfbae019968fa3b3e3ffe80735a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcff83600c55cbfeb643ce59d48e509f" id="r_abcff83600c55cbfeb643ce59d48e509f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcff83600c55cbfeb643ce59d48e509f">Send</a> (const CommunicationRecord *cr, int dest) const</td></tr>
<tr class="memdesc:abcff83600c55cbfeb643ce59d48e509f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends this object over an MPI connection.  <br /></td></tr>
<tr class="separator:abcff83600c55cbfeb643ce59d48e509f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d37e6b69a2a038760ea21d45124ce" id="r_aec3d37e6b69a2a038760ea21d45124ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec3d37e6b69a2a038760ea21d45124ce">BroadCast</a> (const CommunicationRecord *cr, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:aec3d37e6b69a2a038760ea21d45124ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives this object over an MPI connection.  <br /></td></tr>
<tr class="separator:aec3d37e6b69a2a038760ea21d45124ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5df202784ad44ae9c69580a526be6b" id="r_a2a5df202784ad44ae9c69580a526be6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a5df202784ad44ae9c69580a526be6b">Receive</a> (const CommunicationRecord *cr, int src)</td></tr>
<tr class="memdesc:a2a5df202784ad44ae9c69580a526be6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives this object over an MPI connection.  <br /></td></tr>
<tr class="separator:a2a5df202784ad44ae9c69580a526be6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classalexandria_1_1MolProp"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classalexandria_1_1MolProp')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classalexandria_1_1MolProp.xhtml">alexandria::MolProp</a></td></tr>
<tr class="memitem:a809cdf4e528193721cae23bf36c46895 inherit pub_methods_classalexandria_1_1MolProp" id="r_a809cdf4e528193721cae23bf36c46895"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>MolProp</b> ()</td></tr>
<tr class="memdesc:a809cdf4e528193721cae23bf36c46895 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="classalexandria_1_1MolProp.xhtml" title="Contains molecular properties from a range of sources.">MolProp</a> object. <br /></td></tr>
<tr class="separator:a809cdf4e528193721cae23bf36c46895 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d03348c1cbce99a7b7711bd31cf15f1 inherit pub_methods_classalexandria_1_1MolProp" id="r_a2d03348c1cbce99a7b7711bd31cf15f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a2d03348c1cbce99a7b7711bd31cf15f1">checkConsistency</a> ()</td></tr>
<tr class="memdesc:a2d03348c1cbce99a7b7711bd31cf15f1 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the internal consistency of this object.  <br /></td></tr>
<tr class="separator:a2d03348c1cbce99a7b7711bd31cf15f1 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb0618a6e4b462293434aa2dfa21c54 inherit pub_methods_classalexandria_1_1MolProp" id="r_abfb0618a6e4b462293434aa2dfa21c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexandria_1_1MolProp.xhtml">MolProp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#abfb0618a6e4b462293434aa2dfa21c54">self</a> ()</td></tr>
<tr class="separator:abfb0618a6e4b462293434aa2dfa21c54 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7549d78cffe6868f561d53be5edbe97 inherit pub_methods_classalexandria_1_1MolProp" id="r_ac7549d78cffe6868f561d53be5edbe97"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setIndex</b> (int index)</td></tr>
<tr class="memdesc:ac7549d78cffe6868f561d53be5edbe97 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index number for sorting. <br /></td></tr>
<tr class="separator:ac7549d78cffe6868f561d53be5edbe97 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e981c74332ac24b55e50b16a5a31582 inherit pub_methods_classalexandria_1_1MolProp" id="r_a9e981c74332ac24b55e50b16a5a31582"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>getIndex</b> () const</td></tr>
<tr class="memdesc:a9e981c74332ac24b55e50b16a5a31582 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index number for sorting. <br /></td></tr>
<tr class="separator:a9e981c74332ac24b55e50b16a5a31582 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814ac995e8ed9f23717fda4f9e663c4e inherit pub_methods_classalexandria_1_1MolProp" id="r_a814ac995e8ed9f23717fda4f9e663c4e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a814ac995e8ed9f23717fda4f9e663c4e">sameCompound</a> (const <a class="el" href="classalexandria_1_1MolProp.xhtml">MolProp</a> *other)</td></tr>
<tr class="memdesc:a814ac995e8ed9f23717fda4f9e663c4e inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate whether two compounds are the same. The routine will return a list of warnings.  <br /></td></tr>
<tr class="separator:a814ac995e8ed9f23717fda4f9e663c4e inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e19d910c55e45b5a041287aaf526748 inherit pub_methods_classalexandria_1_1MolProp" id="r_a1e19d910c55e45b5a041287aaf526748"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a1e19d910c55e45b5a041287aaf526748">Merge</a> (<a class="el" href="classalexandria_1_1MolProp.xhtml">MolProp</a> *mpi)</td></tr>
<tr class="memdesc:a1e19d910c55e45b5a041287aaf526748 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the content of another <a class="el" href="classalexandria_1_1MolProp.xhtml" title="Contains molecular properties from a range of sources.">MolProp</a> into this one.  <br /></td></tr>
<tr class="separator:a1e19d910c55e45b5a041287aaf526748 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad91bf9839c9eac35f2f0bcae96bd99 inherit pub_methods_classalexandria_1_1MolProp" id="r_a7ad91bf9839c9eac35f2f0bcae96bd99"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>Dump</b> (gmx::TextWriter *tw) const</td></tr>
<tr class="memdesc:a7ad91bf9839c9eac35f2f0bcae96bd99 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of this object to a text writer. <br /></td></tr>
<tr class="separator:a7ad91bf9839c9eac35f2f0bcae96bd99 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6c41ca63a26872ba519655f340f936 inherit pub_methods_classalexandria_1_1MolProp" id="r_a5d6c41ca63a26872ba519655f340f936"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a5d6c41ca63a26872ba519655f340f936">texFormula</a> () const</td></tr>
<tr class="separator:a5d6c41ca63a26872ba519655f340f936 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5ffbde96698a85a9c2993b2b045199 inherit pub_methods_classalexandria_1_1MolProp" id="r_aff5ffbde96698a85a9c2993b2b045199"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>generateComposition</b> ()</td></tr>
<tr class="memdesc:aff5ffbde96698a85a9c2993b2b045199 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the elemental composition. <br /></td></tr>
<tr class="separator:aff5ffbde96698a85a9c2993b2b045199 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f52832079ae00cf06e7c2e182d3c5 inherit pub_methods_classalexandria_1_1MolProp" id="r_a218f52832079ae00cf06e7c2e182d3c5"><td class="memItemLeft" align="right" valign="top">const std::map&lt; const char *, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a218f52832079ae00cf06e7c2e182d3c5">composition</a> () const</td></tr>
<tr class="separator:a218f52832079ae00cf06e7c2e182d3c5 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8805885782653f3409d45aef8f31c427 inherit pub_methods_classalexandria_1_1MolProp" id="r_a8805885782653f3409d45aef8f31c427"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a8805885782653f3409d45aef8f31c427">formula</a> () const</td></tr>
<tr class="separator:a8805885782653f3409d45aef8f31c427 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee042c32add4397f26423425f4ac9310 inherit pub_methods_classalexandria_1_1MolProp" id="r_aee042c32add4397f26423425f4ac9310"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMolname</b> (const std::string &amp;molname)</td></tr>
<tr class="memdesc:aee042c32add4397f26423425f4ac9310 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the molname. <br /></td></tr>
<tr class="separator:aee042c32add4397f26423425f4ac9310 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc264ab70efdc9560eae2828ca1692f1 inherit pub_methods_classalexandria_1_1MolProp" id="r_acc264ab70efdc9560eae2828ca1692f1"><td class="memItemLeft" align="right" valign="top">
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMolname</b> () const</td></tr>
<tr class="memdesc:acc264ab70efdc9560eae2828ca1692f1 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the molname. <br /></td></tr>
<tr class="separator:acc264ab70efdc9560eae2828ca1692f1 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3bffc9165d802a058d84cfb1af0536 inherit pub_methods_classalexandria_1_1MolProp" id="r_aed3bffc9165d802a058d84cfb1af0536"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetIupac</b> (const std::string &amp;iupac)</td></tr>
<tr class="memdesc:aed3bffc9165d802a058d84cfb1af0536 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IUPAC name. <br /></td></tr>
<tr class="separator:aed3bffc9165d802a058d84cfb1af0536 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab860c6b1b02f3cd9d6a1e62401d021e0 inherit pub_methods_classalexandria_1_1MolProp" id="r_ab860c6b1b02f3cd9d6a1e62401d021e0"><td class="memItemLeft" align="right" valign="top">
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getIupac</b> () const</td></tr>
<tr class="memdesc:ab860c6b1b02f3cd9d6a1e62401d021e0 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return IUPAC name or, if not found, the molname. <br /></td></tr>
<tr class="separator:ab860c6b1b02f3cd9d6a1e62401d021e0 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4f93bec153c6f30138962793d6bbce inherit pub_methods_classalexandria_1_1MolProp" id="r_a6a4f93bec153c6f30138962793d6bbce"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCas</b> (const std::string &amp;cas)</td></tr>
<tr class="memdesc:a6a4f93bec153c6f30138962793d6bbce inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CAS (Chemical Abstract Service) identifier, see <a href="http://www.cas.org/">http://www.cas.org/</a>. <br /></td></tr>
<tr class="separator:a6a4f93bec153c6f30138962793d6bbce inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9fb4f43631d1001552ef0bfa1b4216 inherit pub_methods_classalexandria_1_1MolProp" id="r_acb9fb4f43631d1001552ef0bfa1b4216"><td class="memItemLeft" align="right" valign="top">
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCas</b> () const</td></tr>
<tr class="memdesc:acb9fb4f43631d1001552ef0bfa1b4216 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CAS (Chemical Abstract Service) identifier, see <a href="http:://www.cas.org">http:://www.cas.org</a>. <br /></td></tr>
<tr class="separator:acb9fb4f43631d1001552ef0bfa1b4216 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ad9817c0ab53674aad349bc69fc076 inherit pub_methods_classalexandria_1_1MolProp" id="r_a62ad9817c0ab53674aad349bc69fc076"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCid</b> (const std::string &amp;cid)</td></tr>
<tr class="memdesc:a62ad9817c0ab53674aad349bc69fc076 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CID (Chemspider identifier) see <a href="http:://www.chemspider.com">http:://www.chemspider.com</a>. <br /></td></tr>
<tr class="separator:a62ad9817c0ab53674aad349bc69fc076 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669560965bfeab49ead26fbd334fb3ef inherit pub_methods_classalexandria_1_1MolProp" id="r_a669560965bfeab49ead26fbd334fb3ef"><td class="memItemLeft" align="right" valign="top">
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCid</b> () const</td></tr>
<tr class="memdesc:a669560965bfeab49ead26fbd334fb3ef inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CID (Chemspider identifier) see <a href="http:://www.chemspider.com">http:://www.chemspider.com</a>. <br /></td></tr>
<tr class="separator:a669560965bfeab49ead26fbd334fb3ef inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bc3a6ae029cea6d03862e6b0668355 inherit pub_methods_classalexandria_1_1MolProp" id="r_a36bc3a6ae029cea6d03862e6b0668355"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetInchi</b> (const std::string &amp;inchi)</td></tr>
<tr class="memdesc:a36bc3a6ae029cea6d03862e6b0668355 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IUPAC International Chemical <a class="el" href="classalexandria_1_1Identifier.xhtml" title="Class to hold an identifier.">Identifier</a> (InChI) see <a href="http://www.iupac.org/home/publications/e-resources/inchi.html">http://www.iupac.org/home/publications/e-resources/inchi.html</a>. <br /></td></tr>
<tr class="separator:a36bc3a6ae029cea6d03862e6b0668355 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204a27864af8407a23e389efba0cb1f8 inherit pub_methods_classalexandria_1_1MolProp" id="r_a204a27864af8407a23e389efba0cb1f8"><td class="memItemLeft" align="right" valign="top">
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInchi</b> () const</td></tr>
<tr class="memdesc:a204a27864af8407a23e389efba0cb1f8 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IUPAC International Chemical <a class="el" href="classalexandria_1_1Identifier.xhtml" title="Class to hold an identifier.">Identifier</a> (InChI) see <a href="http://www.iupac.org/home/publications/e-resources/inchi.html">http://www.iupac.org/home/publications/e-resources/inchi.html</a>. <br /></td></tr>
<tr class="separator:a204a27864af8407a23e389efba0cb1f8 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb737b6ab66cd81f3445f2cc788dc407 inherit pub_methods_classalexandria_1_1MolProp" id="r_acb737b6ab66cd81f3445f2cc788dc407"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#acb737b6ab66cd81f3445f2cc788dc407">hasQMProperty</a> (<a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a> mpo, double T, <a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> jt) const</td></tr>
<tr class="separator:acb737b6ab66cd81f3445f2cc788dc407 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c921677bf3f3518df1058f885128631 inherit pub_methods_classalexandria_1_1MolProp" id="r_a3c921677bf3f3518df1058f885128631"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="classalexandria_1_1GenericProperty.xhtml">GenericProperty</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a3c921677bf3f3518df1058f885128631">qmProperty</a> (<a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a> mpo, double T, <a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> jt) const</td></tr>
<tr class="memdesc:a3c921677bf3f3518df1058f885128631 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a QM property according to <a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544" title="Enum describing the type of the QM job computed by the Gaussian software.">JobType</a> below.  <br /></td></tr>
<tr class="separator:a3c921677bf3f3518df1058f885128631 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d417cd3563ff3cae39e275f34d9dbe inherit pub_methods_classalexandria_1_1MolProp" id="r_a87d417cd3563ff3cae39e275f34d9dbe"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="classalexandria_1_1GenericProperty.xhtml">GenericProperty</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a87d417cd3563ff3cae39e275f34d9dbe">expProperty</a> (<a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a> mpo, double T) const</td></tr>
<tr class="memdesc:a87d417cd3563ff3cae39e275f34d9dbe inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an Experimental property.  <br /></td></tr>
<tr class="separator:a87d417cd3563ff3cae39e275f34d9dbe inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e547f4577a6a4ebdd7e781c5c1130b inherit pub_methods_classalexandria_1_1MolProp" id="r_aa2e547f4577a6a4ebdd7e781c5c1130b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddCategory</b> (const std::string &amp;category)</td></tr>
<tr class="memdesc:aa2e547f4577a6a4ebdd7e781c5c1130b inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a classification category for this molecule. <br /></td></tr>
<tr class="separator:aa2e547f4577a6a4ebdd7e781c5c1130b inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c903af5ac4ec0a8866ae7afff2e798 inherit pub_methods_classalexandria_1_1MolProp" id="r_ab8c903af5ac4ec0a8866ae7afff2e798"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NCategory</b> ()</td></tr>
<tr class="memdesc:ab8c903af5ac4ec0a8866ae7afff2e798 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of categories. <br /></td></tr>
<tr class="separator:ab8c903af5ac4ec0a8866ae7afff2e798 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fda13efc73a637a08e693e31737abc4 inherit pub_methods_classalexandria_1_1MolProp" id="r_a3fda13efc73a637a08e693e31737abc4"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>categoryConst</b> () const</td></tr>
<tr class="memdesc:a3fda13efc73a637a08e693e31737abc4 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return category array as const. <br /></td></tr>
<tr class="separator:a3fda13efc73a637a08e693e31737abc4 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2847d4b9d2a086cdce4c2a7b0f732ca4 inherit pub_methods_classalexandria_1_1MolProp" id="r_a2847d4b9d2a086cdce4c2a7b0f732ca4"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SearchCategory</b> (const std::string &amp;catname) const</td></tr>
<tr class="memdesc:a2847d4b9d2a086cdce4c2a7b0f732ca4 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if catname is an existing category. <br /></td></tr>
<tr class="separator:a2847d4b9d2a086cdce4c2a7b0f732ca4 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5dc7cc79af467842d0340af1470358 inherit pub_methods_classalexandria_1_1MolProp" id="r_a5a5dc7cc79af467842d0340af1470358"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearCategory</b> ()</td></tr>
<tr class="memdesc:a5a5dc7cc79af467842d0340af1470358 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the category vector. <br /></td></tr>
<tr class="separator:a5a5dc7cc79af467842d0340af1470358 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6e9b98c31c18a9988b2d480489fa5 inherit pub_methods_classalexandria_1_1MolProp" id="r_a7cd6e9b98c31c18a9988b2d480489fa5"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NAtom</b> () const</td></tr>
<tr class="memdesc:a7cd6e9b98c31c18a9988b2d480489fa5 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of atoms in the compound. <br /></td></tr>
<tr class="separator:a7cd6e9b98c31c18a9988b2d480489fa5 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8491611820e180fee86eb9173b9b48cd inherit pub_methods_classalexandria_1_1MolProp" id="r_a8491611820e180fee86eb9173b9b48cd"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasAllAtomTypes</b> () const</td></tr>
<tr class="memdesc:a8491611820e180fee86eb9173b9b48cd inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boolean stating whether all atoms have valid atom types. <br /></td></tr>
<tr class="separator:a8491611820e180fee86eb9173b9b48cd inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76ade588417815abe742c040dae4f9 inherit pub_methods_classalexandria_1_1MolProp" id="r_a8f76ade588417815abe742c040dae4f9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddBond</b> (const <a class="el" href="classalexandria_1_1Bond.xhtml">Bond</a> &amp;b)</td></tr>
<tr class="memdesc:a8f76ade588417815abe742c040dae4f9 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classalexandria_1_1Bond.xhtml" title="Chemical bond in a molecule with associated bond order.">Bond</a> element. <br /></td></tr>
<tr class="separator:a8f76ade588417815abe742c040dae4f9 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566582dae51274441c648e62a668cad0 inherit pub_methods_classalexandria_1_1MolProp" id="r_a566582dae51274441c648e62a668cad0"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>BondExists</b> (const <a class="el" href="classalexandria_1_1Bond.xhtml">Bond</a> &amp;b)</td></tr>
<tr class="memdesc:a566582dae51274441c648e62a668cad0 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a <a class="el" href="classalexandria_1_1Bond.xhtml" title="Chemical bond in a molecule with associated bond order.">Bond</a> element is present already. <br /></td></tr>
<tr class="separator:a566582dae51274441c648e62a668cad0 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e26796cc237d9949826c81d693c08 inherit pub_methods_classalexandria_1_1MolProp" id="r_afa5e26796cc237d9949826c81d693c08"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>NBond</b> () const</td></tr>
<tr class="memdesc:afa5e26796cc237d9949826c81d693c08 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of <a class="el" href="classalexandria_1_1Bond.xhtml" title="Chemical bond in a molecule with associated bond order.">Bond</a> elements. <br /></td></tr>
<tr class="separator:afa5e26796cc237d9949826c81d693c08 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252224b58ea1d8e7bcdab93177bda0b3 inherit pub_methods_classalexandria_1_1MolProp" id="r_a252224b58ea1d8e7bcdab93177bda0b3"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="classalexandria_1_1Bond.xhtml">Bond</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bondsConst</b> () const</td></tr>
<tr class="memdesc:a252224b58ea1d8e7bcdab93177bda0b3 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const vector of bonds. <br /></td></tr>
<tr class="separator:a252224b58ea1d8e7bcdab93177bda0b3 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf78678b3472cb15197e14a13a6d14af inherit pub_methods_classalexandria_1_1MolProp" id="r_aaf78678b3472cb15197e14a13a6d14af"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="classalexandria_1_1Bond.xhtml">Bond</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>bonds</b> ()</td></tr>
<tr class="memdesc:aaf78678b3472cb15197e14a13a6d14af inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the whole bond array for editing. <br /></td></tr>
<tr class="separator:aaf78678b3472cb15197e14a13a6d14af inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647382bc88f3f433f50cb23504e95fba inherit pub_methods_classalexandria_1_1MolProp" id="r_a647382bc88f3f433f50cb23504e95fba"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="classalexandria_1_1Fragment.xhtml">Fragment</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>fragments</b> () const</td></tr>
<tr class="memdesc:a647382bc88f3f433f50cb23504e95fba inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fragments of this molecule. <br /></td></tr>
<tr class="separator:a647382bc88f3f433f50cb23504e95fba inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dd7cee83f12c2e055436936a859555 inherit pub_methods_classalexandria_1_1MolProp" id="r_ad5dd7cee83f12c2e055436936a859555"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="classalexandria_1_1Fragment.xhtml">Fragment</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>fragmentPtrConst</b> () const</td></tr>
<tr class="memdesc:ad5dd7cee83f12c2e055436936a859555 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fragments of this molecule. <br /></td></tr>
<tr class="separator:ad5dd7cee83f12c2e055436936a859555 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278c2179dc90692fd1381397432e1111 inherit pub_methods_classalexandria_1_1MolProp" id="r_a278c2179dc90692fd1381397432e1111"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="classalexandria_1_1Fragment.xhtml">Fragment</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>fragmentPtr</b> ()</td></tr>
<tr class="memdesc:a278c2179dc90692fd1381397432e1111 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return editable fragments of this molecule. <br /></td></tr>
<tr class="separator:a278c2179dc90692fd1381397432e1111 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8836afc4d6b55673ca63caf03e3c6c inherit pub_methods_classalexandria_1_1MolProp" id="r_aeb8836afc4d6b55673ca63caf03e3c6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#aeb8836afc4d6b55673ca63caf03e3c6c">addFragment</a> (const <a class="el" href="classalexandria_1_1Fragment.xhtml">Fragment</a> &amp;f)</td></tr>
<tr class="separator:aeb8836afc4d6b55673ca63caf03e3c6c inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ea09e68cb8dc43c7b54eddf7832a26 inherit pub_methods_classalexandria_1_1MolProp" id="r_a92ea09e68cb8dc43c7b54eddf7832a26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a92ea09e68cb8dc43c7b54eddf7832a26">renumberResidues</a> ()</td></tr>
<tr class="memdesc:a92ea09e68cb8dc43c7b54eddf7832a26 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renumber the residues to one residue per fragment. If there is no correct experiment (Opt or Topology) this is not possible and the function will return false.  <br /></td></tr>
<tr class="separator:a92ea09e68cb8dc43c7b54eddf7832a26 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7752c4d9632619ad44e4608f95f804 inherit pub_methods_classalexandria_1_1MolProp" id="r_aae7752c4d9632619ad44e4608f95f804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#aae7752c4d9632619ad44e4608f95f804">generateFragments</a> (<a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *msg_handler, const ForceField *pd)</td></tr>
<tr class="separator:aae7752c4d9632619ad44e4608f95f804 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af924eb6822fb1117933689cf8af418 inherit pub_methods_classalexandria_1_1MolProp" id="r_a3af924eb6822fb1117933689cf8af418"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFragments</b> ()</td></tr>
<tr class="memdesc:a3af924eb6822fb1117933689cf8af418 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fragment information. <br /></td></tr>
<tr class="separator:a3af924eb6822fb1117933689cf8af418 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf7bf878e4442450566f30fc9809705 inherit pub_methods_classalexandria_1_1MolProp" id="r_a2cf7bf878e4442450566f30fc9809705"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>totalCharge</b> ()</td></tr>
<tr class="memdesc:a2cf7bf878e4442450566f30fc9809705 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total charge by summing over all fragments. <br /></td></tr>
<tr class="separator:a2cf7bf878e4442450566f30fc9809705 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e558b7fec0fcb4adf7c0621d23369 inherit pub_methods_classalexandria_1_1MolProp" id="r_a2a1e558b7fec0fcb4adf7c0621d23369"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>totalMultiplicity</b> ()</td></tr>
<tr class="memdesc:a2a1e558b7fec0fcb4adf7c0621d23369 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total multiplicity from all fragments. <br /></td></tr>
<tr class="separator:a2a1e558b7fec0fcb4adf7c0621d23369 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda17d6847a8afabeb225748fae2c018 inherit pub_methods_classalexandria_1_1MolProp" id="r_afda17d6847a8afabeb225748fae2c018"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><b>totalMass</b> () const</td></tr>
<tr class="memdesc:afda17d6847a8afabeb225748fae2c018 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total mass by summing over all fragments. <br /></td></tr>
<tr class="separator:afda17d6847a8afabeb225748fae2c018 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bbf1d04526b9ba1a15abbc01b335b9 inherit pub_methods_classalexandria_1_1MolProp" id="r_a44bbf1d04526b9ba1a15abbc01b335b9"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>symmetryNumber</b> () const</td></tr>
<tr class="memdesc:a44bbf1d04526b9ba1a15abbc01b335b9 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total symmetry number. <br /></td></tr>
<tr class="separator:a44bbf1d04526b9ba1a15abbc01b335b9 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbcd2df5574f4c4fd62686a24c91296 inherit pub_methods_classalexandria_1_1MolProp" id="r_adfbcd2df5574f4c4fd62686a24c91296"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#adfbcd2df5574f4c4fd62686a24c91296">findExperimentConst</a> (<a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> job) const</td></tr>
<tr class="memdesc:adfbcd2df5574f4c4fd62686a24c91296 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first calculation that matches the specification.  <br /></td></tr>
<tr class="separator:adfbcd2df5574f4c4fd62686a24c91296 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304c710bf64026ec41e956c29548d04d inherit pub_methods_classalexandria_1_1MolProp" id="r_a304c710bf64026ec41e956c29548d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a304c710bf64026ec41e956c29548d04d">findExperiment</a> (<a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> job)</td></tr>
<tr class="memdesc:a304c710bf64026ec41e956c29548d04d inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first calculation that matches the specification.  <br /></td></tr>
<tr class="separator:a304c710bf64026ec41e956c29548d04d inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddaa9cca9028fa8f3a86b087d974856 inherit pub_methods_classalexandria_1_1MolProp" id="r_a3ddaa9cca9028fa8f3a86b087d974856"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddExperiment</b> (<a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> myexp)</td></tr>
<tr class="memdesc:a3ddaa9cca9028fa8f3a86b087d974856 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an experiment. <br /></td></tr>
<tr class="separator:a3ddaa9cca9028fa8f3a86b087d974856 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260f010932dadea2158d6a5b5b1797b inherit pub_methods_classalexandria_1_1MolProp" id="r_a6260f010932dadea2158d6a5b5b1797b"><td class="memItemLeft" align="right" valign="top">
const std::vector&lt; <a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>experimentConst</b> () const</td></tr>
<tr class="memdesc:a6260f010932dadea2158d6a5b5b1797b inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const vector of experiments. <br /></td></tr>
<tr class="separator:a6260f010932dadea2158d6a5b5b1797b inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1e87e7e9903abfbf2bb6adacadc039 inherit pub_methods_classalexandria_1_1MolProp" id="r_a4b1e87e7e9903abfbf2bb6adacadc039"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>experiment</b> ()</td></tr>
<tr class="memdesc:a4b1e87e7e9903abfbf2bb6adacadc039 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return mutable vector of experiments. <br /></td></tr>
<tr class="separator:a4b1e87e7e9903abfbf2bb6adacadc039 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967a7a20dd7d74b3f188c884dad7ab8 inherit pub_methods_classalexandria_1_1MolProp" id="r_a1967a7a20dd7d74b3f188c884dad7ab8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespacealexandria.xhtml#a56471cd4751607922e68419e4c9b541e">ExperimentConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndExperiment</b> () const</td></tr>
<tr class="memdesc:a1967a7a20dd7d74b3f188c884dad7ab8 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of experiment vector. <br /></td></tr>
<tr class="separator:a1967a7a20dd7d74b3f188c884dad7ab8 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332f917f1188accb0cd8ecf616aa02c7 inherit pub_methods_classalexandria_1_1MolProp" id="r_a332f917f1188accb0cd8ecf616aa02c7"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classalexandria_1_1Experiment.xhtml">Experiment</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LastExperiment</b> ()</td></tr>
<tr class="memdesc:a332f917f1188accb0cd8ecf616aa02c7 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to the last inserted experiment or nullptr if the number of experiments is zero. <br /></td></tr>
<tr class="separator:a332f917f1188accb0cd8ecf616aa02c7 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6917b939a2b8fba339b2a507a11af72 inherit pub_methods_classalexandria_1_1MolProp" id="r_ae6917b939a2b8fba339b2a507a11af72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#ae6917b939a2b8fba339b2a507a11af72">Send</a> (const CommunicationRecord *cr, int dest) const</td></tr>
<tr class="memdesc:ae6917b939a2b8fba339b2a507a11af72 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends this object over an MPI connection.  <br /></td></tr>
<tr class="separator:ae6917b939a2b8fba339b2a507a11af72 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2746730bf805bbb8994e776d2b2cdd inherit pub_methods_classalexandria_1_1MolProp" id="r_a0c2746730bf805bbb8994e776d2b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a0c2746730bf805bbb8994e776d2b2cdd">BroadCast</a> (const CommunicationRecord *cr, int root, MPI_Comm comm)</td></tr>
<tr class="memdesc:a0c2746730bf805bbb8994e776d2b2cdd inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives this object over an MPI connection.  <br /></td></tr>
<tr class="separator:a0c2746730bf805bbb8994e776d2b2cdd inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e81006596a96ad37ea1f570ed5173f3 inherit pub_methods_classalexandria_1_1MolProp" id="r_a5e81006596a96ad37ea1f570ed5173f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classalexandria_1_1MolProp.xhtml#a5e81006596a96ad37ea1f570ed5173f3">Receive</a> (const CommunicationRecord *cr, int src)</td></tr>
<tr class="memdesc:a5e81006596a96ad37ea1f570ed5173f3 inherit pub_methods_classalexandria_1_1MolProp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives this object over an MPI connection.  <br /></td></tr>
<tr class="separator:a5e81006596a96ad37ea1f570ed5173f3 inherit pub_methods_classalexandria_1_1MolProp"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a36234276426a845b9515e59946ef0592" name="a36234276426a845b9515e59946ef0592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36234276426a845b9515e59946ef0592">&#9670;&#160;</a></span>atoms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; ActAtom &gt; * alexandria::ACTMol::atoms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>atoms data for editing </dd></dl>

</div>
</div>
<a id="a793e33843cc0e960ad5e8a407d54c8cd" name="a793e33843cc0e960ad5e8a407d54c8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793e33843cc0e960ad5e8a407d54c8cd">&#9670;&#160;</a></span>atomsConst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; ActAtom &gt; &amp; alexandria::ACTMol::atomsConst </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>atoms data for reading only </dd></dl>

</div>
</div>
<a id="a08c7484e07835bfc311bb9c02de3b667" name="a08c7484e07835bfc311bb9c02de3b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c7484e07835bfc311bb9c02de3b667">&#9670;&#160;</a></span>atomsConst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; ActAtom &gt; &amp; alexandria::ACTMol::atomsConst </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>atoms data </dd></dl>

</div>
</div>
<a id="a82c09ff912332fd2ec7e6e6fae49f849" name="a82c09ff912332fd2ec7e6e6fae49f849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c09ff912332fd2ec7e6e6fae49f849">&#9670;&#160;</a></span>bondOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double alexandria::ACTMol::bondOrder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ai</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aj</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bond order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>Atom I </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aj</td><td>Atom J </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bond order or 0 if not present </dd></dl>

</div>
</div>
<a id="aec3d37e6b69a2a038760ea21d45124ce" name="aec3d37e6b69a2a038760ea21d45124ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d37e6b69a2a038760ea21d45124ce">&#9670;&#160;</a></span>BroadCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ACTMol::BroadCast </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm</td>          <td class="paramname"><span class="paramname"><em>comm</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives this object over an MPI connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>data structure for MPI communication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The MPI root </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>The MPI communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8" title="Enumerated type holding the result status of communication operations.">CommunicationStatus</a> of the operation </dd></dl>

</div>
</div>
<a id="a6dd80b30685e6056794ff5bc9d461835" name="a6dd80b30685e6056794ff5bc9d461835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd80b30685e6056794ff5bc9d461835">&#9670;&#160;</a></span>calculateEnergyOld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexandria.xhtml#aa30e28974e4670e2e6637f1e25114a18">ACTMessage</a> alexandria::ACTMol::calculateEnergyOld </td>
          <td>(</td>
          <td class="paramtype">const t_commrec *</td>          <td class="paramname"><span class="paramname"><em>crtmp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>coordinates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PaddedVector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; *</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real *</td>          <td class="paramname"><span class="paramname"><em>shellForceRMS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the forces and energies For a polarizable model the shell positions are minimized. This code is maintained only for comparing ACT native energies and forces to the gromacs code. Do not use in production code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crtmp</td><td>Temporary communication record with one core only. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinates</td><td>The atomic coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>Force array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">energies</td><td>The energy components </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shellForceRMS</td><td>Root mean square force on the shells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacealexandria.xhtml#aa30e28974e4670e2e6637f1e25114a18ae0aa021e21dddbd6d8cecec71e9cf564" title="No error, all OK.">ACTMessage::OK</a> if everything worked fine, error code otherwise. </dd></dl>

</div>
</div>
<a id="a28422257a8694767a7ffc5163e9a60a3" name="a28422257a8694767a7ffc5163e9a60a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28422257a8694767a7ffc5163e9a60a3">&#9670;&#160;</a></span>calculateInteractionEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::calculateInteractionEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComputer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; *</td>          <td class="paramname"><span class="paramname"><em>einter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>interactionForces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>separateInductionCorrection</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the interaction energies. For a system with multiple fragments this will compute Epot(system) - Sum_f Epot(f) where f are the fragments. Importantly the individual components of the energy are stored. For a polarizable model the shell positions are minimized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>A message handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComputer</td><td>The code to run the calculations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">einter</td><td>The interaction energy components </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interactionForces</td><td>The forces on the atoms due to the interacting components </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">coords</td><td>Atomic coordinates (shell positions can be updated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separateInductionCorrection</td><td>Whether to store InductionCorrection separately or add it to Induction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd854b8de8f4c44f6b0622758f3bca2f" name="abd854b8de8f4c44f6b0622758f3bca2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd854b8de8f4c44f6b0622758f3bca2f">&#9670;&#160;</a></span>datasetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iMolSelect alexandria::ACTMol::datasetType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the dataset type </dd></dl>

</div>
</div>
<a id="aa8ade008e59340775b9cc2fd6fd09cb5" name="aa8ade008e59340775b9cc2fd6fd09cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ade008e59340775b9cc2fd6fd09cb5">&#9670;&#160;</a></span>energy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ACTMol::energy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a></td>          <td class="paramname"><span class="paramname"><em>mpo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>ener</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the GROMACS energy data</dd></dl>
<p>Return an energy component </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpo</td><td>The particular term that is requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ener</td><td>The value found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the energy is found </dd></dl>

</div>
</div>
<a id="a8a7bc0c48519cd4c9cf0116430d35a79" name="a8a7bc0c48519cd4c9cf0116430d35a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7bc0c48519cd4c9cf0116430d35a79">&#9670;&#160;</a></span>energyTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const real * alexandria::ACTMol::energyTerms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a GROMACS style array with energy terms </dd></dl>

</div>
</div>
<a id="a931b963ecbafa452205bf19432ce005c" name="a931b963ecbafa452205bf19432ce005c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931b963ecbafa452205bf19432ce005c">&#9670;&#160;</a></span>experCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gmx::RVec &gt; alexandria::ACTMol::experCoords </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; gmx::RVec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xxx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a modified coordinate vector of the molecule based on the input. The output array includes shells and/or vsites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xxx</td><td>Input coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Modified coordinate array. </dd></dl>

</div>
</div>
<a id="a97d45938656c86aa4551271071a2e8ed" name="a97d45938656c86aa4551271071a2e8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d45938656c86aa4551271071a2e8ed">&#9670;&#160;</a></span>forceEnergyMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::forceEnergyMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; double, double &gt; &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>forceMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classalexandria_1_1ACTEnergy.xhtml">ACTEnergy</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>energyMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexandria.xhtml#a5f41c3a634b231705347c9cc55d2a6d3">ACTEnergyMapVector</a> *</td>          <td class="paramname"><span class="paramname"><em>interactionEnergyMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, std::map&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a>, double &gt; &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>energyComponentMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>separateInductionCorrection</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute energies and forces for all structures The optimized structure as well as all the excited structures will be used to compute the energy and forces. Store the results in vectors containing two doubles, first the reference, then the calculated one. Forces are stored as a vector of structures and then a vector of atoms. Energies are stored as a 1D vector pair. All energy components are stored as a vector of reference energies paired with a map of ACT energy components. The <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74" title="Interaction type.">InteractionType</a> index points to the energy type in the energyComponentsMap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>A message handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>The force computer utility </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forceMap</td><td>The forces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">energyMap</td><td>The energy components for a single structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interactionEnergyMap</td><td>The interaction energies </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">energyComponentMap</td><td>The energy components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separateInductionCorrection</td><td>Whether to store InductionCorrection separately or add it to Induction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a981bda40721a2add528c8678e775dd85" name="a981bda40721a2add528c8678e775dd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981bda40721a2add528c8678e775dd85">&#9670;&#160;</a></span>GenerateAcmCharges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexandria.xhtml#aa30e28974e4670e2e6637f1e25114a18">ACTMessage</a> alexandria::ACTMol::GenerateAcmCharges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate atomic partial charges using EEM or SQE. If shells are present they will be minimized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_handler</td><td>Message and status handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>The force computer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>The coordinates, will be updated for shells </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>The forces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69756ff92778bbb9d1f7377e05f20997" name="a69756ff92778bbb9d1f7377e05f20997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69756ff92778bbb9d1f7377e05f20997">&#9670;&#160;</a></span>generateCharges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::generateCharges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__module__alexandria.xhtml#ga0420bcd6e71d174f3360e37de2bd9f63">ChargeGenerationAlgorithm</a></td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateQProps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate or copy atomic partial charges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message Handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>Force computer utility </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>The algorithm for determining charges. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>The coordinates, will be updated for shells </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>This routine will compute energies and forces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updateQProps</td><td>Whether or not to update the qprops (dipoles, quadrupoles etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fab9193c798febaa15ffdf606e38435" name="a1fab9193c798febaa15ffdf606e38435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fab9193c798febaa15ffdf606e38435">&#9670;&#160;</a></span>generateCommercials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; alexandria::ACTMol::generateCommercials </td>
          <td>(</td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gmx::RVec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate molecule info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>The force computer utility </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coords</td><td>The coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a text about the compound including properties and citation infor </dd></dl>

</div>
</div>
<a id="a8a7d05937a09cb7be6c974ad2d05f3dd" name="a8a7d05937a09cb7be6c974ad2d05f3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d05937a09cb7be6c974ad2d05f3dd">&#9670;&#160;</a></span>GenerateCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::GenerateCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gmx::RVec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real</td>          <td class="paramname"><span class="paramname"><em>spacing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real</td>          <td class="paramname"><span class="paramname"><em>border</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>reffn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pcfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pdbdifffn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>potfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhofn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hisfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>difffn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>diffhistfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gmx_output_env_t *</td>          <td class="paramname"><span class="paramname"><em>oenv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>For debugging and information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coords</td><td>Atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>Force computer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacing</td><td>The grid space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">border</td><td>The amount of space around the molecule </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reffn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcfn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdbdifffn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">potfn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhofn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hisfn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">difffn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diffhistfn</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oenv</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0700ebe07e49fdccc5450ea333d7649a" name="a0700ebe07e49fdccc5450ea333d7649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0700ebe07e49fdccc5450ea333d7649a">&#9670;&#160;</a></span>GenerateTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::GenerateTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacealexandria.xhtml#afea33eb2c3ea5c817c514a01bda7320c">missingParameters</a></td>          <td class="paramname"><span class="paramname"><em>missing</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It generates the atoms structure which will be used to print the topology file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missing</td><td>How to treat missing parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d874e4a90aeef2e7afb2cad3ae824cc" name="a5d874e4a90aeef2e7afb2cad3ae824cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d874e4a90aeef2e7afb2cad3ae824cc">&#9670;&#160;</a></span>getExpProps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::getExpProps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a>, <a class="el" href="group__group__molprop.xhtml#ga672ac03ebb5c06d86e7e44fe27ee8421">iqmType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iqm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real</td>          <td class="paramname"><span class="paramname"><em>watoms</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxESP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the properties from QM (Optimized structure) or from experiment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message and status handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iqm</td><td>Determine whether to allow exp or QM results or both for each property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">watoms</td><td>Weight for the potential on the atoms in doing the RESP fit. Should be 0 in most cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxESP</td><td>Percentage of the ESP points to consider (&lt;= 100) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437c500792a8ea59a14479a3e7cf7775" name="a437c500792a8ea59a14479a3e7cf7775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437c500792a8ea59a14479a3e7cf7775">&#9670;&#160;</a></span>hasMolPropObservable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ACTMol::hasMolPropObservable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__molprop.xhtml#ga8bfc33a3b3865d2059148814b8aa56d2">MolPropObservable</a></td>          <td class="paramname"><span class="paramname"><em>mpo</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether data is present </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpo</td><td>The observable to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any data of the type is present </dd></dl>

</div>
</div>
<a id="a3f1031d997ba139fc7b19af13daf4bbd" name="a3f1031d997ba139fc7b19af13daf4bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1031d997ba139fc7b19af13daf4bbd">&#9670;&#160;</a></span>haveShells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ACTMol::haveShells </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if shells are present </dd></dl>

</div>
</div>
<a id="a782be3898bfee12792bb636c2280f96e" name="a782be3898bfee12792bb636c2280f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782be3898bfee12792bb636c2280f96e">&#9670;&#160;</a></span>jobType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacealexandria.xhtml#a248329690ee811b9cce02d415113f544">JobType</a> &amp; alexandria::ACTMol::jobType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the job type corresponding to coordinates </dd></dl>

</div>
</div>
<a id="ac2dff908d8be0c3cc692f665eb4536b6" name="ac2dff908d8be0c3cc692f665eb4536b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dff908d8be0c3cc692f665eb4536b6">&#9670;&#160;</a></span>levelOfTheory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string alexandria::ACTMol::levelOfTheory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the level of theory used for data </dd></dl>

</div>
</div>
<a id="abc7e6379bc12c4c7fa86dee5bf430398" name="abc7e6379bc12c4c7fa86dee5bf430398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7e6379bc12c4c7fa86dee5bf430398">&#9670;&#160;</a></span>linearMolecule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool alexandria::ACTMol::linearMolecule </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether this is a linear molecule </dd></dl>

</div>
</div>
<a id="aeb34c870c16f52e1d92bd8783b86a5da" name="aeb34c870c16f52e1d92bd8783b86a5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb34c870c16f52e1d92bd8783b86a5da">&#9670;&#160;</a></span>minimizeShells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::minimizeShells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize shell positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message Handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>Force computer utility </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>The coordinates, will be updated for shells </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>This routine will compute energies and forces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2867c7e8ce65abe45a6e58a0675b8c5" name="ae2867c7e8ce65abe45a6e58a0675b8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2867c7e8ce65abe45a6e58a0675b8c5">&#9670;&#160;</a></span>molProp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classalexandria_1_1MolProp.xhtml">MolProp</a> * alexandria::ACTMol::molProp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the molprop object </dd></dl>

</div>
</div>
<a id="a415132d468f2cfc296de9c484f310a2a" name="a415132d468f2cfc296de9c484f310a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415132d468f2cfc296de9c484f310a2a">&#9670;&#160;</a></span>nRealAtoms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int alexandria::ACTMol::nRealAtoms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of real atoms, i.e. not shells or vsites </dd></dl>

</div>
</div>
<a id="ac97f86de88712861cd06c2735c4630e0" name="ac97f86de88712861cd06c2735c4630e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97f86de88712861cd06c2735c4630e0">&#9670;&#160;</a></span>PrintConformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::PrintConformation </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gmx::RVec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>writeShells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the coordinates corresponding to topology after adding shell particles and/or vsites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coords</td><td>The atomic coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeShells</td><td>Whether or not to write the shell particles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>The simulation box / unitcell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93ee9ee60e6b0ed7dc8a0ba160310f01" name="a93ee9ee60e6b0ed7dc8a0ba160310f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ee9ee60e6b0ed7dc8a0ba160310f01">&#9670;&#160;</a></span>PrintTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::PrintTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msg_handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gmx::RVec &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bITP</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the topology that was generated previously in GROMACS format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_handler</td><td>For warning and status </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>The force computer utility </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coords</td><td>The coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bITP</td><td>Whether or not to write an itp file iso top file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e462e0b7272d7276d61bde48974ee1" name="a33e462e0b7272d7276d61bde48974ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e462e0b7272d7276d61bde48974ee1">&#9670;&#160;</a></span>qProps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classalexandria_1_1ACTQprop.xhtml">ACTQprop</a> &gt; * alexandria::ACTMol::qProps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classalexandria_1_1QtypeProps.xhtml">QtypeProps</a> vector for editing </dd></dl>

</div>
</div>
<a id="ad6c54cbe0c5b9f903cf235434c14f1e4" name="ad6c54cbe0c5b9f903cf235434c14f1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c54cbe0c5b9f903cf235434c14f1e4">&#9670;&#160;</a></span>qPropsConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classalexandria_1_1ACTQprop.xhtml">ACTQprop</a> &gt; &amp; alexandria::ACTMol::qPropsConst </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classalexandria_1_1QtypeProps.xhtml">QtypeProps</a> vector for reading </dd></dl>

</div>
</div>
<a id="ab55c64a56f62d58701578b47db5f16c8" name="ab55c64a56f62d58701578b47db5f16c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55c64a56f62d58701578b47db5f16c8">&#9670;&#160;</a></span>realAtoms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; alexandria::ACTMol::realAtoms </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the indexex of real atoms </dd></dl>

</div>
</div>
<a id="a2a5df202784ad44ae9c69580a526be6b" name="a2a5df202784ad44ae9c69580a526be6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5df202784ad44ae9c69580a526be6b">&#9670;&#160;</a></span>Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ACTMol::Receive </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives this object over an MPI connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>data structure for MPI communication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8" title="Enumerated type holding the result status of communication operations.">CommunicationStatus</a> of the operation </dd></dl>

</div>
</div>
<a id="abcff83600c55cbfeb643ce59d48e509f" name="abcff83600c55cbfeb643ce59d48e509f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcff83600c55cbfeb643ce59d48e509f">&#9670;&#160;</a></span>Send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8">CommunicationStatus</a> alexandria::ACTMol::Send </td>
          <td>(</td>
          <td class="paramtype">const CommunicationRecord *</td>          <td class="paramname"><span class="paramname"><em>cr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends this object over an MPI connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cr</td><td>data structure for MPI communication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="group__module__alexandria.xhtml#gae19a23cad87643283e0eac1e8654d4f8" title="Enumerated type holding the result status of communication operations.">CommunicationStatus</a> of the operation </dd></dl>

</div>
</div>
<a id="a9bcb0fb9d2221a003eef738f36499358" name="a9bcb0fb9d2221a003eef738f36499358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcb0fb9d2221a003eef738f36499358">&#9670;&#160;</a></span>set_datasetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::set_datasetType </td>
          <td>(</td>
          <td class="paramtype">iMolSelect</td>          <td class="paramname"><span class="paramname"><em>dataset_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the dataset type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataset_type</td><td>The new type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6b4019ff7edc71d72738bccf08b2dff" name="ad6b4019ff7edc71d72738bccf08b2dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b4019ff7edc71d72738bccf08b2dff">&#9670;&#160;</a></span>setBasisset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setBasisset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set QM basis set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basis</td><td>Will be new basis set if not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c6677e0f0b685e22beffbf47562f976" name="a8c6677e0f0b685e22beffbf47562f976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6677e0f0b685e22beffbf47562f976">&#9670;&#160;</a></span>setCharges() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setCharges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qcustom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy charges from array to topologies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qcustom</td><td>The charges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40af35d63aa2dd4bc892eb269a150245" name="a40af35d63aa2dd4bc892eb269a150245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40af35d63aa2dd4bc892eb269a150245">&#9670;&#160;</a></span>setCharges() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setCharges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacealexandria.xhtml#a56446590bd6167854d1b3462215b10b0">ChargeMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>qmap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy charges from qmap to topologies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message Handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qmap</td><td>The charge map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa86ae0eab237769260f3dc1a68cbf0a8" name="aa86ae0eab237769260f3dc1a68cbf0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86ae0eab237769260f3dc1a68cbf0a8">&#9670;&#160;</a></span>setCharges() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setCharges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy charges from force field to topologies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message Handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a819bd736428b2a277c4b1de62b07dafa" name="a819bd736428b2a277c4b1de62b07dafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819bd736428b2a277c4b1de62b07dafa">&#9670;&#160;</a></span>setCharges() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setCharges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classalexandria_1_1MsgHandler.xhtml">MsgHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>msghandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>qread</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy charges from input (molprop) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msghandler</td><td>Message Handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>The force field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qread</td><td>The type to read, e.g. Mulliken </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0440b97826f2d776cbe0d1b37b4cb571" name="a0440b97826f2d776cbe0d1b37b4cb571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0440b97826f2d776cbe0d1b37b4cb571">&#9670;&#160;</a></span>setMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>method</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set QM method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>Will be new method if not empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa783bbb2b72721c53db5ecc021458eec" name="aa783bbb2b72721c53db5ecc021458eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa783bbb2b72721c53db5ecc021458eec">&#9670;&#160;</a></span>setSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::setSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacealexandria.xhtml#a8be9254d6f9b31942d8fc30f78af14ef">eSupport</a></td>          <td class="paramname"><span class="paramname"><em>esup</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the support type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>The support type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac361cdb7aa60429f5d5c27c98a874257" name="ac361cdb7aa60429f5d5c27c98a874257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac361cdb7aa60429f5d5c27c98a874257">&#9670;&#160;</a></span>support()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacealexandria.xhtml#a8be9254d6f9b31942d8fc30f78af14ef">eSupport</a> alexandria::ACTMol::support </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>how this compound is supported on this processor </dd></dl>

</div>
</div>
<a id="a2c491a3ff6e7d07d2f3a65e873c50793" name="a2c491a3ff6e7d07d2f3a65e873c50793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c491a3ff6e7d07d2f3a65e873c50793">&#9670;&#160;</a></span>UpdateIdef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::UpdateIdef </td>
          <td>(</td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacealexandria.xhtml#a3b7484b4a2e88315ea98274715fcfe74">InteractionType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>iTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateZeta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update internal structures for bondtype due to changes in pd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iTypes</td><td>Interaction types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updateZeta</td><td>Whether to update the atomic zeta as well </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad95e71ce504e215f6e099187ceed58cb" name="ad95e71ce504e215f6e099187ceed58cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95e71ce504e215f6e099187ceed58cb">&#9670;&#160;</a></span>updateQprops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alexandria::ACTMol::updateQprops </td>
          <td>(</td>
          <td class="paramtype">const ForceField *</td>          <td class="paramname"><span class="paramname"><em>pd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classalexandria_1_1ForceComputer.xhtml">ForceComputer</a> *</td>          <td class="paramname"><span class="paramname"><em>forceComp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; gmx::RVec &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update internal structures with electric moments etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>Data structure containing atomic properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceComp</td><td>Force computer utility </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>This routine will compute energies and forces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e5d685c2f4794218234c4f75031922" name="a63e5d685c2f4794218234c4f75031922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e5d685c2f4794218234c4f75031922">&#9670;&#160;</a></span>xOriginal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gmx::RVec &gt; alexandria::ACTMol::xOriginal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a coordinate vector of the molecule corresponding to the first experiment with Jobtype Opt or Topology or SP. The array includes shells and/or vsites. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>not suitable experiment is present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/act/alexandria/<b>actmol.h</b></li>
<li>src/act/alexandria/<b>actmol.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacealexandria.xhtml">alexandria</a></li><li class="navelem"><a class="el" href="classalexandria_1_1ACTMol.xhtml">ACTMol</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
